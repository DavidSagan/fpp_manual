% !TEX TS-program = PDFlatex
% !TEX encoding = UTF-8 Unicode

% Example of the Memoir class, an alternative to the default LaTeX classes such as article and book, with many added features built into the class itself.

%\documentclass[12pt,a4paper]{memoir} % for a long document
%\documentclass[french,12pt,a4paper,article]{memoir} % for a short document
\documentclass[english,12pt,article]{article} % for a short document
%\documentclass[french,12pt,a4paper]{article} % for a short document

\usepackage{babel}
\usepackage[utf8]{inputenc} % set input encoding to utf8
\usepackage{amsmath, amsthm, amssymb}

\input{amssym.def}
\input{amssym.tex}

% Don't forget to read the Memoir manual: memman.PDF
\usepackage{enumitem}
\usepackage{alltt}
\usepackage{color}
\usepackage{pgfplotstable}
\usepackage{pgfplots}
\usetikzlibrary{plotmarks}
\usepackage[colorlinks=true,linkcolor=blue]{hyperref} 
\usepackage{graphicx}
\usepackage{listings}
\usepackage[T1]{fontenc}   % so _, <, and > print correctly in text.
\usepackage[strings]{underscore}    % to use "_" in text
%\frenchspacing
\usepackage{pdfpages}

\input{macros.tex}

\newlength{\dPar}
\setlength{\dPar}{1.5ex}
\setlength{\parskip}{\dPar}
\setlength{\parindent}{0ex}

%-----------------------------------------------------------------

\title{ \protect \large Manual for FPP:   The Fully Polymorphic Package}    
\newcommand{\subtitle}{Using examples from  PTC and BMAD }
\author{Ã‰tienne Forest \\ Tsukuba, Japon }
%\date{12 avril 2018} 
%\date{21 juillet 2018} % Delete this line to display the current date

\bibliographystyle{prsty}
  
\begin{document}
 


\newpage 
{\footnotesize
\tableofcontents % the asterisk means that the contents itself isn't put into the ToC
}
\newpage 
\maketitle
%--------------------------------------------------------------
\section{Introduction to FPP/PTC}
\label{sec:fppptc}

\begin{figure}[tb]
  \centering
  \includegraphics[width=4in]{FPP-PTC.pdf}
  \caption{The Fully Polymorphic Package (FPP) part of the FPP/PTC library provides manipulation and analysis of Taylor series and maps and the Polymorphic Tracking Code (PTC) part provides the physics from which accelerators can be analyzed.}
  \label{f:fpp-ptc}
\end{figure}

%--------------------------------------------------------------
\subsection{FPP and PTC}

FPP/PTC is an object oriented, open source, subroutine library for
\begin{enumerate}[itemsep=-0.5ex, topsep=-0.4ex]
\item The manipulation and analysis of Taylor series and Taylor maps.
\item Modeling of charged particle beams in accelerators using Taylor maps.
\end{enumerate}

FPP/PTC has two parts. The Fully Polymorphic Package (FPP) is the part that deals with Taylor series and maps. FPP is pure math independent\footnote{It does not contain any physical description of what an accelerator is. } of any "physics". The Polymorphic Tracking Code (PTC) part of the library deals with the modeling of particle beams and accelerators. PTC contains the "physics" and relies on FPP for producing and manipulating Taylor maps. This is illustrated in \Fig{f:fpp-ptc}. Roughly, FPP can be subdivided into two parts(see \sec{sec:subp}), a Taylor manipulation part for basic manipulations of Taylor series and an analysis part to do things like normal form analysis. PTC uses the Taylor manipulation part of FPP for things like the construction of Taylor maps. Additionally, PTC uses the analysis tools of FPP. A closer look at FPP shows the existence of a Differential Algebra (DA) package\footnote{Should really be called the TPSA package of Berz. We will demystify this jargon latter.} within FPP. This package was originally coded by Martin Berz.

%--------------------------------------------------------------
\subsection{Where to Obtain FPP/PTC}

%--------------------------------------------------------------
\subsection{Concepts}\label{s:concepts}

FPP/PTC is written in object oriented Fortran2008. 

FPP/PTC uses double precision real numbers defined using the type "real(dp)" "dp" is defined in FPP/PTC to correspond to double precision. For example, to define in a program a real number named "time" one would write:
\begin{example}
  real(dp) time
\end{example}

In Fortran, a "structure" (also called a "derived type") is like a struct in C or a class in C++. A structure holds a set of components as defined by the programmer. With FPP, the "taylor" structure is used to hold a taylor series. For practical calculations it is often not convenient to deal directly with the taylor structure. For reasons that will be discussed later, the preferred structure to use is a polymorphic structure called "\vn{real_8}". In general, a "polymorphic" variable is a variable that can act in different ways depending on the context of the program. Here, a \vn{real_8} variable can act as if it were a real number or it can act as if it were a Taylor series depending upon how it is initialized.
An example program will make this clear.
\begin{code}
  program real_8_example
  use pointer_lattice   ! Read in structure definitions, etc.
  implicit none

  type (real_8) r8      ! Define a real_8 variable named r8
  real(dp) x            ! Define a double precision number

  !

  longprint = .false.         ! Shorten "call print" output
  call init (only_2d0, 3, 0)  ! Initialize: #Vars = 2, Order = 3

  x = 0.1d0
  call alloc(r8)          ! Initialize memory for r8
  r8 = x                  ! This will make r8 act as a real

  print *, 'r8 is now acting as a real:'
  call print (r8)

  r8 = 0.7d0 + dz_8(1) + 2*dz_8(2)**3 ! Init r8 as a Taylor series
  print *, 'r8 is now acting as a Taylor series:'
  call print(r8)

  r8 = r8**4  ! Raise the Taylor series to the 4th power
  print *, 'This is r8^4:'
  call print (r8)

  call kill(r8)
  end program
\end{code}

The variable \vn{x} is defined as a double precision real number. The line
\begin{example}
  type (real_8) r8
\end{example}
defines \vn{r8} as an instance of a \vn{real_8} variable and the line
\begin{example}
  call alloc(r8)
\end{example}
initializes \vn{r8}. This initialization must be done before \vn{r8} is used. After \vn{r8} is used, any memory that has been allocated for use with \vn{r8} is reclaimed by calling the \vn{kill} routine
\begin{example}
  call kill(r8)
\end{example}
Strictly speaking, the \vn{kill} is not necessary here since \vn{kill} is called at end of the program. However, in a subroutine or function, all local instances of \vn{real_8} variables must be killed otherwise there will be a memory leak.

When \vn{r8} is set to the real number \vn{x} in the line
\begin{example}
    r8 = x
\end{example}
this will cause \vn{r8} to act as a real number. This is verified by printing the value of \vn{r8} in the lines
\begin{example}
  print *, 'r8 is now acting as a real:'
  call print (r8)
\end{example}
The output is just a single real number indicating that \vn{r8} is acting as a real:
\begin{example}
  r8 is now acting as a real:'
  0.100000000000000
\end{example}
Notice that the \vn{print} statement uses the Fortran intrinsic print function while the \vn{call print} statement uses the overloaded print subroutine defined by \vn{FPP}.

When \vn{r8} is set to a Taylor series in the line
\begin{example}
  r8 = 0.7d0 + dz_8(1) + 2*dz_8(2)**3 ! Init r8 as a Taylor series
\end{example}
this will cause \vn{r8} to act as a Taylor series. To understand how this initialization works, first consider the initialization of FPP/PTC which was done by the line
\begin{example1}
  call init (only_2d0, 3, 0)  ! Initialize FPP/PTC. #Vars = 2, Order = 3
\end{example1}
The first argument, \vn{only_2d0},  configured FPP/PTC to construct any Taylor series as a function of two variables. These two variables will be called $z_1$ and $z_2$ here. The second argument, \vn{3}, gives the order at which the Taylor series is truncated to. That is, after this initialization, all Taylor series $t$ will be of the form
\begin{equation}
    t = \sum_{i,j}^{0 \le i+j \le 3} C_{ij} \, z_1^i \, z_2^j
\end{equation}
In the above initialization of \vn{r8}, \vn{dz_8(1)} represents the variable $z_1$ and \vn{dz_8(2)} represents the variable $z_2$. Thus \vn{r8} is initialized to the Taylor series
\begin{equation}
    t = 0.7 + z_1 + 2 \, z_2^3
\end{equation}
This is confirmed by printing \vn{r8} after it has been set via the lines
\begin{example}
  print *, 'r8 is now acting as a Taylor series:'
  call print(r8)
\end{example}
The output is:
\begin{example}
  r8 is now acting as a Taylor series:
  Properties, NO =    3, NV =    2, INA =   21
   *********************************************

     0  0.7000000000000000       0  0
     1   1.000000000000000       1  0
     3   2.000000000000000       0  3
\end{example}
Each line in the above output, after the line with the asterisks, represents one term in the Taylor series. The general form for printing a Taylor term is:
\begin{example}
  <term-order>   <term-coefficient>    <z1-exponent>  <z2-exponent>
\end{example}
The <term-order> is the order of the term. That is, the sum of the exponents. For example, the last line in the above printout is
\begin{example}
   3   2.000000000000000       0  3
\end{example}
and this line represents the term $2 \, z_1^0 \, z_2^3$. 

Once \vn{r8} has been initialized, it can be used in expressions. Thus the line
\begin{example}
  r8 = r8**4  ! Raise the Taylor series to the 4th power
\end{example}
raises \vn{r8} to the 4th power and puts the result back into \vn{r8}. This is confirmed by the final print which produces
\begin{example}
  This is r8^4:
  Properties, NO =    3, NV =    2, INA =   23
  *********************************************

    0  0.2400999999999999       0  0
    1   1.372000000000000       1  0
    2   2.940000000000000       2  0
    3   2.800000000000000       3  0
    3   2.743999999999999       0  3
\end{example}
Notice that the map has been truncated so that no term has an order higher than 3 as expected. Expressions using \vn{real_8} variables involve overloaded operators as discussed in section \sec{sec:over}.

%--------------------------------------------------------------
\subsection{Real\_8 Under the Hood}\label{sec:real8}

The particulars of how the \vn{real_8} structure is defined are generally not of interest to the general user. But it is instructive to take a quick look. In the \vn{FPP} code the \vn{real_8} structure is defined as:
\begin{example1}
  TYPE REAL_8
     TYPE (TAYLOR) T      !  USED IF TAYLOR
     REAL(DP) R           !    USED IF REAL
     INTEGER KIND  !  0,1,2,3 (1=REAL,2=TAYLOR,3=TAYLOR KNOB)
     INTEGER I   !   USED FOR KNOBS AND SPECIAL KIND=0
     REAL(DP) S   !   SCALING FOR KNOBS AND SPECIAL KIND=0
     LOGICAL(LP) :: ALLOC  1 IF TAYLOR IS ALLOCATED IN DA-PACKAGE
  END TYPE REAL_8
\end{example1}
The \vn{t} component of the structure is of type \vn{taylor} and is used if a \vn{real_8} variable is acting as a Taylor series. The \vn{r} component is used if a \vn{real_8} variable is acting as a real number. The \vn{kind} component is an integer that sets the behavior of a \vn{real_8} variable. Besides behaving as \vn{real} or a \vn{Taylor series}, a \vn{real_8} variable may behave as a "\vn{knob}" which will be explained later.

The \vn{real_8} structure contains a component of type \vn{taylor}. The definition of the taylor structure is
\begin{example1}
  TYPE TAYLOR
     INTEGER I       !  integer I is a pointer in old da-package of Berz
  END TYPE TAYLOR
\end{example1}
The component \vn{i} is a pointer to the differential algebra package of Berz that is contained in FPP. The details of how a Taylor series is stored in the structure is not important here. What is important is that this structure can be used to hold a Taylor series.

The reason for hiding a Taylor series under the hood is to defer its use to running time. We really do not know in a tracking code like PTC when the user will need a Taylor series and even what the parameters of that series might be: phase space, if so how many (2,4,6,?), and parameters such as quadrupole strengths which are taken from the huge set of magnets present in the system.


\subsection{Fundamental Types}\label{sec:funtype}

In this section we list all the simple types that exist in FPP in order of increasing complexity.

\subsubsection{Type taylor}

\begin{example}
  TYPE TAYLOR
     INTEGER I   
  END TYPE TAYLOR
\end{example}

This type overloads the Taylor series of the original real ``DA-Package'' of Berz. See \sref{sec:real8}. Its direct use is discouraged. Tracking programs should use the real polymorph type \vn{real_8}.

\subsubsection{Type complextaylor}\label{sec:complextaylor}

\begin{example}
  TYPE COMPLEXTAYLOR
     type (taylor) r
     type (taylor) i
  END TYPE COMPLEXTAYLOR
\end{example}
The \vn{complextaylor} is made of two Taylor series which represent the real and imaginary parts. Its direct use is also discouraged as was already explained in Sec.~\sref{sec:real8}.

Consider this code fragment:
\begin{code}
   type(complextaylor) z1,z2
 
   call init(2,4)
   .
   .
   .
   z1 = dz_t(1) + i_ * dz_t(2)
   z2=z1**2
   
   write(6,*) " this is z1 "
   call PRINT(z1)   
   write(6,*) " this is z2 "
   call PRINT(z2)
\end{code}

The variable \vn{z1} is, in Leibnitz  mathematical  language, $dx+i \, dy$. The variable \vn{z2} must simply be $dx^2-dy^2+i\, 2\, dx dy$.
\begin{example1}
  this is z1

 Properties, NO =    2, NV =    4, INA =   23
 *********************************************

   1   1.000000000000000       1  0  0  0


 Properties, NO =    2, NV =    4, INA =   24
 *********************************************

   1   1.000000000000000       0  1  0  0

  this is z2

 Properties, NO =    2, NV =    4, INA =   25
 *********************************************

   2   1.000000000000000       2  0  0  0
   2  -1.000000000000000       0  2  0  0


 Properties, NO =    2, NV =    4, INA =   26
 *********************************************

   2   2.000000000000000       1  1  0  0
\end{example1}

%-------------------------------------------------------------------
\subsubsection{Type \protect\vn{real_8}}  \label{sec:real8code}

The \vn{real_8} type was discussed in Sec.~\sref{s:concepts} and Sec.~\sref{sec:real8}.
This type is the most important type if you write a tracking code of respectable length.  Imagine that your code tracks in one degree of freedom (1-d-f). Then you will push two phase space variables through your magnets, let us call them ${\bf z}=(z_1,z_2)$. These variables will denote  the position and the tangent of an angle in our little example.  If it is your  intention to always extract a Taylor series around a special orbit, then  it would suffice to declare as \vn{taylor} only the phase space variables ${\bf z}=(z_1,z_2)$ and any temporary variables the code might used during its calculations. 

But what if we want to have a Taylor map that also depends upon some parameter or parameters of the lattice. For example, a map can include quadrupole strengths as independent variables in the maps. Such variables are called ``\vn{knobs}.'' Since this is a user decision, it is best if the code decides at execution time using the type \vn{real_8}.
As an example, consider the code:

\begin{code}
program my_small_code_real_8
use polymorphic_complextaylor
implicit none
type(real_8) :: z(2)  
real(dp) :: z0(2) = [0, 0]  ! special orbit
type(reaL_8)  :: L , B, K_q , K_s 
integer :: nd = 1 , no = 2 , np = 0, ip
longprint = .false.         ! Shorten "call print" output
! nd = number of degrees of freedom
! no =  order of Taylor series
! Number of extra variables beyond 2*nd

call alloc(z)
call alloc( L , B, K_q , K_s )
np=0
print * , "Give  L and parameter ordinality (0 if not a parameter)"
read(5,*) L%r , ip
np=np+ip
call make_it_knob(L,ip);  np=np+ip;
print * , "Give  B  and parameter ordinality (0 if not a parameter)"
read(5,*) K_q%r , ip
print * , "Give  K_q and parameter ordinality (0 if not a parameter)"
read(5,*) K_q%r , ip
call make_it_knob(K_q,ip);  np=np+ip;
print * , "Give  K_s and parameter ordinality (0 if not a parameter)"
read(5,*) K_s%r , ip
call make_it_knob(K_s,ip); np=np+ip;
print * , "The order of the Taylor series ?"
read(5,*) no

call init(no,nd,np) ! Initializes TPSA 

z(1)=z0(1) + dz_8(1) ! <--- Taylor monomial z_1 added
z(2)=z0(2) + dz_8(2) ! <--- Taylor monomial z_2 added

call track(z)

call print(z)

contains

subroutine track(z)
implicit none
type(real_8) :: z(2) 
 z(1)=z(1)+L*z(2) 
 z(2)=z(2)-B-K_q*z(1)-K_s*z(1)**2 
end subroutine track

end program my_small_code_real_8
\end{code}

In this little code, there is one drift of length \vn{L} followed by a multipole kick that contains a dipole of strength \vn{B}, a quadrupole of strength \vn{K_q} and a sextupole of strength \vn{K_s}. We run the code ignoring the parameters:

\begin{example1}
 Give  L and parameter ordinality (0 if not a parameter)
1 0
 Give  B  and parameter ordinality (0 if not a parameter)
0 0
 Give  K_q and parameter ordinality (0 if not a parameter)
.1 0
 Give  K_s and parameter ordinality (0 if not a parameter)
0 0
 The order of the Taylor series ?
2

 Properties, NO =    2, NV =    2, INA =   20
 *********************************************

   1   1.000000000000000       1  0
   1   1.000000000000000       0  1


 Properties, NO =    2, NV =    2, INA =   21
 *********************************************

   1 -0.1000000000000000       1  0
   1  0.9000000000000000       0  1
\end{example1}

This little program produces Taylor series to second order in the phase space variables ${\bf z}=(z_1,z_2)$ similar to the programs \vn{Transport} and \vn{Marylie}.
However, we can now require that the multipole strengths be variables of the Taylor series without recompiling the program. In this example, we make the quadrupole strength the third variable of TPSA:  $K_q=0.1 + dz_3$.

\begin{example2}
 Give  L and parameter ordinality (0 if not a parameter)
1 0
 Give  B  and parameter ordinality (0 if not a parameter)
0 0
 Give  K_q and parameter ordinality (0 if not a parameter)
.1 1
 Give  K_s and parameter ordinality (0 if not a parameter)
0 0
 The order of the Taylor series ?
2

 Properties, NO =    2, NV =    3, INA =   22
 *********************************************

   1   1.000000000000000       1  0  0
   1   1.000000000000000       0  1  0


 Properties, NO =    2, NV =    3, INA =   23
 *********************************************

   1 -0.1000000000000000       1  0  0
   1  0.9000000000000000       0  1  0
   2  -1.000000000000000       1  0  1
   2  -1.000000000000000       0  1  1
\end{example2}

Again, we must emphasize that while it would have been easy here to use the type \vn{taylor} for all the variables, it is totally infeasible in a real tracking code to either recompile the code or allow all parameters of the systems to be Taylor series. This is why typical matrix\footnote{This is not true of Berz's COSY INFINITY which handles variable memory of TPSA within its own internal language.} codes, not using TPSA, are limited to a small set of Taylor variables, usually the six phase space variables.

So in summary a \vn{real_8} polymorph can be as mentioned in \sec{sec:real8}:

\begin{enumerate}
 \item A real number
 \item a Taylor series with real coefficients (\vn{taylor})
 \item a knob which is a simple temporary Taylor series activated only if needed
\end{enumerate}

\subsubsection{Type complex_8}  \label{sec:complex_8}

The type \vn{complex_8} is the polymorphic version of the \vn{complextaylor} type just as the \vn{real_8} type is the polymorphic version of the \vn{taylor} type.

The type \vn{complex_8} is rarely used in a tracking code since all quantities we compute are ultimately real. However once in a while it is useful to go into complex coordinates temporarily. If the type \vn{complex_8} did not exist, then a code could become extremely difficult to write. This happens a lot when Maxwell's equations are  written in cylindrical coordinates. In such a case, if ${\bf z}=(x,p_x,y,p_y)$, then most intermediate calculations involve a quantity $q=x+i\,y$. It in such a case, the complex polymorph is useful. This happens in the tracking code for some magnets in PTC but it is generally hidden from a normal programmer using PTC. 
 
\begin{example1}
  TYPE COMPLEX_8
    TYPE (COMPLEXTAYLOR) T 
    COMPLEX(DP) R
    LOGICAL(LP) ALLOC
    INTEGER KIND
    INTEGER I,J 
    COMPLEX(DP) S
  END TYPE COMPLEX_8
\end{example1}
  
 As in the case of the real polymorph, the \vn{t} component contains the complex Taylor series and the \vn{r} component contains the complex number if the polymorph is not a Taylor series. 
  
  \subsection{Type probe_8 specific to PTC}\label{sec:codetype}

The types discussed in \sec{sec:funtype} are useful to anyone who decides to use FPP to write their own tracking code. In fact there is nothing ``tracking'' about these types. One could write a code to solve a problem in finance or biology using  type \vn{real_8}. But since our ultimate goal is to describe the analysis part of FPP, we need to say a little bit more about the objects used in PTC.

 PTC uses the following \vn{probe_8} structure for tracking 

\begin{example1}
type probe_8
   type(real_8) x(6)     ! Polymorphic orbital ray
   type(spinor_8) s(3)   ! Polymorphic spin s(1:3)
   type(quaternion_8) q
   type(rf_phasor_8)  ac(nacmax)  ! Modulation of magnet
   integer:: nac=0 !  number of modulated clocks <=nacmax
   real(dp) E_ij(6,6)   !  Envelope for stochastic radiation
   real(dp) x0(6) ! initial value of the ray for TPSA calculations with c_damap
          .
          .
          .
end type probe_8
\end{example1}

As the reader can see, it is made out of other structures which are themselves made of \vn{real_8} or simple real numbers These components are described later.

%-------------------------------
\subsubsection{The x(6) component of probe_8}\label{sec:codetypex6}

The \vn{x(6)} component represents the orbital phase space part of the tracked particle.
 
 \begin{itemize}
\item In \vn{PTC}, when ``\vn{time}'' units is used, the orbital phase space is: 
%
%]|Expr|[#b @`b___})+# b'4" Chicago^: ;bP8&c0!*-="!Helvetica|:! |
%|""*|:"x,H1,Z6,I,]<c!$1(1x,L<2^$^p^x_^$^p^0_},Ly,L<2^$^p^y_^$^|
%|p^0_},L<2(""#Symbol^:#&c0  D:"&c0!*E}("$^p^0_c}},LcT"$Monaco^:$ |
%|or c:#&c0  D:"&c0!*T}}:! : -;}& b!( b"0 b#8 b$@ b%H b&P!WW}]|[
\begin{align} x(1:6)=
\left({x,{{p}_{x} \over {p}_{0}},y,{{p}_{y} \over {p}_{0}},{\Delta E \over {p}_{0}c},cT~{\rm o}{\rm r}~{\rm c}\Delta T}\right) \end{align}
\item When \vn{BMAD} units are used, the orbital phase space is:
%
%]|Expr|[#b @`b___})+# b'4" Chicago^: ;bP8&c0!*-="!Helvetica|:! |
%|""*|:"x,H1,Z6,I,]<c!$1(4x,L<2^$^p^x_^$^p^0_},Ly,L<2^$^p^x_^$^|
%|p^0_},L,M"#Symbol^:#&c0  b:"&c0!*cT"$Monaco^:$ or ,M:#&c0  b:$&c0!*c|
%|:#&c0  D:"&c0!*T,L<2(":#&c0  D:"&c0!*p}^$^p^0_}}}:! : -;|
%|}& b!( b"0 b#8 b$@ b%H b&P!WW}]|[
\begin{align} x(1:6)=
\left({x,{{p}_{x} \over {p}_{0}},y,{{p}_{x} \over {p}_{0}},-\beta cT~{\rm o}{\rm r}~-\beta {\rm c}\Delta T,{\Delta p \over {p}_{0}}}\right) \end{align}
\end{itemize}
where
%
%]|Expr|[#b @`b___})*# b'4" Chicago^: ;bP8&c0!*-="!Helvetica|:! |
%|""Symbol^:"&c0  D"#*|:#&c0!*T,]T,M$^T(!ref}_:! : -;|
%|}& b!( b"0 b#8 b$@ b%H b&P!WW}]|[
\begin{align} \Delta T=
T-{T}_{ref} \end{align}

With 1-d-f tracking, only the first two phase space coordinates are used. With 2-d-f, only the first four phase space coordinates are used.

\subsubsection{The spin and quaternion components of probe_8}\label{sec:code spin}

PTC can track spin. There are two ways to track spin: one method uses a regular spin matrix and the other uses a quaternion.
Since there are three independent directions of spin, PTC tracks three directions: this saves time if one wants to construct a spin matrix. The three directions are represented by the three \vn{s(3)} components which are of type \vn{spinor_8}. The components of a \vn{spinor_8} are

\begin{example}
  type spinor_8
    type(real_8) x(3)  ! x(3) = (s_x, s_y, s_z)   with  |s|=1
  end type spinor_8
\end{example}

For example, if one tracks on the closed orbit, the initial conditions are
%
%]|Expr|[#b @`b___})9# b'4" Chicago^: ;bP8&c0!*-="!Helvetica|:! |
%|""*|:"s,H1,I:!,F,]<c!$1(%:"1,L0,L0}}: ;bP;/":!;bP8 :"s,H2,I:!,F,]|
%|<c!$1(%:"0,L1,L0}}: ;bP;/":!;bP8 :"s,H3,I:!,F,]<c!$1(%:"0,L0,L|
%|1}}: -;}& b!( b"0 b#8 b$@ b%H b&P!WW}]|[
\begin{align} s(1)&=\left({1,0,0}\right)\nonumber \\
 s(2)&=\left({0,1,0}\right)\nonumber \\
 s(3)&=\left({0,0,1}\right)\end{align}
 
The tracking of these vectors for one turn will allow us to construct  the one-turn spin matrix around the closed orbit. Thus if the orbital polymorphs are powered to be appropriate Taylor series in n-d-f (n=1,2, or 3), we can produce a complete approximate 3 by 3 matrix  for the spin. This is shown in \sec{sec:mappro}.

The polymorphic  quaternion \vn{quaternion_8}, not surprisingly, is given by: 
\begin{example}
  type  quaternion_8 
    type(real_8) x(0:3)
  end type quaternion_8
\end{example}
   
As we will see, it is a more efficient representation for the spin and it simplifies the analysis. From the theory of rotations in three dimensions, we know that there is one invariant unit direction and one angle of rotation around this axis. The unit quaternion has exactly the same freedom: four numbers whose squares add up to one. Once more we claim that if its polymorphic components are properly initialized, a generic Taylor map for the quaternions emerges. This is described in \sec{sec:mappro}.
   
\subsubsection{The components of type rf_phasor_8}\label{sec:codemod}
  
The \vn{rf_phasor_8} type  is  somewhat complex to explain but their definition is simple:

\begin{example}
  type rf_phasor_8
    type(real_8)  x(2)  ! The two hands of the clock
    type(real_8) om     ! the omega of the modulation
    real(dp) t          ! the pseudo-time
  end type rf_phasor_8
\end{example}
    
The variables \vn{x(2)} represents a vector rotating at a frequency \vn{om} based on a pseudo-time related to the reference time of the ``design'' particle. As the the \vn{probe_8} traverses a magnet, in the integration routines, magnets can use that pseudo-clock to modulate their multipole components. In the end, as we will see, the components \vn{rf_phasor_8%x(2)} are used to add two additional dimensions to a Taylor map. This will be explained later when we discuss the types germane to analysis.
    
\subsubsection{The real components E_i_j(6,6)}\label{sec:codesto}
   
We will say little about the \vn{E_i_j(6,6)} structure except that it allows us to store the quantum fluctuations due to radiation. PTC, like most codes, does not attempt to go beyond linear dynamics when dealing with photon fluctuations. When radiation is present, the polymorphs \vn{x(6)} contain the final closed trajectory (with classical radiation) and   \vn{E_i_j(6,6)  } measures the fluctuations $<x_i\, x_j>\,i,j=1,6$ due to photon emission. PTC does not attempt any polymorphic computations: you get the zeroth order results around the orbit computed.
    
    
\subsubsection{Real(dp) type probe specific to PTC}\label{sec:codetyper}

In theory, it is possible to have a code which always uses the polymorphs \vn{real_8} and nothing else. However this is not what PTC does due to computational speed considerations. To see this
consider the following code fragment
\begin{code}
  type(real_8) a,b,c
      . 
      .
  c=a+b
\end{code}
      
How many internal questions does the \vn{+} operation requires?   First it must decide if \vn{a} is real, Taylor or knob?  The same thing applies to the polymorph \vn{b}. On the basis of the answer, it must branch into  9 possibilities before it can even start to compute this sum.   This overhead slows down a polymorphic calculation even if all the variables are real.
To get around this, PTC has a type \vn{probe} defined as
\begin{example}
  type probe
    real(dp) x(6)
    type(spinor) s(3)
    type(quaternion) q
    type(rf_phasor)  AC(nacmax)
    integer:: nac=0
      .
      .
  end type probe
\end{example}
The components of the \vn{probe} are all analogous to the components of the \vn{probe_8} with \vn{real_8} replaced by \vn{real(dp)}. With this, most operations are acting directly and quickly on Fortran intrinsic types.

The way PTC uses \vn{probe} and \vn{probe_8} is that for a given a PTC tracking routine that uses \vn{probe_8} there is a duplicate tracking routine that uses \vn{probe}. The \vn{probe_8} routine is to be used when tracking is to be done using Taylor maps and the \vn{probe} routine is to be used for tracking ordinary real rays. \vn{Probe} is equivalent to tracking \vn{probe_8} setting the truncation order to 0.

The same routine duplication happens with routines that use \vn{real_8}. In this case the corresponding routine will use a \vn{real(dp)}. As an example, consider the subroutine in the example of \sec{sec:real8code}:
\begin{code}
  subroutine track(z)
  implicit none
  type(real_8) :: z(2) 
  z(1)=z(1)+L*z(2) 
  z(2)=z(2)-B-K_q*z(1)-K_s*z(1)**2 
  end subroutine track
\end{code}

This routines computes the effect of a ``drift'' followed by a multipole ``kick'' in the jargon of accelerator physicists.  The corresponding \vn{real(dp)} version is:
\begin{code}
  subroutine track(z)
  implicit none
  real(dp) :: z(2)            <-------- instead of type(real_8) :: z(2) 
  z(1)=z(1)+L*z(2) 
  z(2)=z(2)-B-K_q*z(1)-K_s*z(1)**2 
  end subroutine track
\end{code}
this is indeed a trivial  drift-kick routine.   
 
    
As we said, PTC tracks \vn{probe} or  \vn{probe_8}.  It is very easy to modify the above routines to mimic this feature of PTC:

\begin{code}
  module my_code
  use tree_element_module
  implicit none
  private trackr,trackp
  type(real_8)  :: L ,B, K_q , K_s 
  real(dp) :: L0 , B0, K_q0 , K_s0 
  real(dp) par(4)
  integer ip(4)
      
  interface track
    module procedure trackr
    module procedure trackp 
  end interface

  contains
        .
        .
        .
  subroutine trackr(p) ! for probe
  implicit none
  type(probe) :: p
  p%x(1)=p%x(1)+L0*p%x(2) 
  p%x(2)=p%x(2)-B0-K_q0*p%x(1)-K_s0*p%x(1)**2 
  end subroutine trackr
      
  subroutine trackp(p) ! for probe_8
  implicit none
  type(probe_8) :: p
  p%x(1)=p%x(1)+L*p%x(2) 
  p%x(2)=p%x(2)-B-K_q*p%x(1)-K_s*p%x(1)**2 
  end subroutine trackp
          .
          .
          .
  end module my_code
\end{code}

Then a call to \vn{track(p)} will either call    
\begin{itemize} 
  \item \vn{trackr(p)} if \vn{p} is a \vn{probe}
  \item or \vn{trackp(p)} if \vn{p} is a \vn{probe_8}
\end{itemize}  
    
If we call  \vn{track(p)} where \vn{p} is a  \vn{probe_8}, then the resulting \vn{p} could be a Taylor series which approximates the true map\footnote{The true map of the code is always what you get by calling \vn{track}.} of the code.
    
For example, in \sec{sec:real8code}, we got the following results for the final polymorphs:
\begin{example1}
 Properties, NO =    2, NV =    2, INA =   20
 *********************************************

   1   1.000000000000000       1  0
   1   1.000000000000000       0  1


 Properties, NO =    2, NV =    2, INA =   21
 *********************************************

   1 -0.1000000000000000       1  0
   1  0.9000000000000000       0  1
\end{example1}

It is clear that one could deduce from the above result:
%
%]|Expr|[#b @`b___})b A# b'4" Chicago^: ;bP8&c0!*-="!Helvetica|:! |
%|-[-<bf ""*|:"z:!-],F,]<c!$1^["" ^1^1($,M0,N1}(#0,N9}}}: ,H:! |
%|$^"#Times|:#z^1_:! -<cr $^:#z^2_:! : ,I:#,K O: ,H$^:#z_^2: ,I|
%|:! : ;8/<:";bP8eq,Zlin1: ;8/=;bP8-;}& b!( b"0 b#8 b$@ b%H b&P!WW}]|[
\begin{align} {\bf z}&=\left({\begin{array}{cc}1&1\\
-0.1&0.9\end{array}}\right)\left({\begin{array}{c} {z}_{1} \cr {z}_{2} \end{array}}\right)+\ O\left({\begin{array}{c}{z}^{2}\end{array}}\right) \label{eq:lin1}\end{align}

Therefore we could say that ${\bf z}$ or equivalently a \vn{probe_8}  is a ``Taylor map.''  But this is not done in PTC for several reasons:

\begin{enumerate}
\item The variables  $(z_1,z_2)$ could  be  infinitesimal with respect to machine parameters, in which case any attempt to concatenate the matrix is pure nonsense 
\item\label{item:st}  One should not confuse a set with an algebraic structure which  the  set itself.
\end{enumerate}

Item \ref{item:st} requires an explanation. Take for example  a pair of real numbers from the set  $\mathbb{R} \times \mathbb{R}$.  A priori we have no idea what structures are imposed on this pair of numbers. Indeed the structure could be    a complex number field, a ring of differentials (running TPSA to order 1 with one parameter),  a one-dimensional complex vector space, a two dimensional real vector space, a twice infinite dimensional  vector space on the field of rationals, etc... In a code (or in a mathematical article), we could decide to  distinguish these structures by using a different ``plus'' sign depending on the structure: $+$ if complex numbers and say a $\oplus$ if they are vectors. 

If the object in FPP is extremely important, the solution in FPP is to define  a new type and  keep the $+,*,\ldots $ signs for this new type.  Therefore we do not allow the concatenation of \vn{probe_8} even when it is reasonable. Instead we construct a map, type \vn{c_damap} described in \sec{sec:cdamap}, only and only if this construction is meaningful.  FPP does not prevent the construction of meaningless Taylor maps. The \vn{c_damap}  of PTC will be meaningful if the rules between the \vn{probe_8} and \vn{c_damap}  types are religiously\footnote{Neither FPP, nor PTC nor  BMAD prevents  a user to do crazy things and shove a  \vn{probe_8} into a \vn{c_damap}  anyway he sees fit. But beware of the results.}  observed.  

Conversely we define a new operator when the creation of a new type is too cumbersome due to its infrequent usage. We do this on \vn{c_damap} allowing ``DA'' concatenation and ``TPSA'' concatenation via a different symbol rather than a different type. This will  be explained in \sec{sec:typeops}.


\subsection{The type c_taylor and the Taylor maps c_damap for analysis}\label{sec:raymap}
 
\subsubsection{The type {\vn{c_taylor}} and the complex Berz's package }\label{sec:cdamap}
  
  The reader will notice two seemingly identical Fortran files : \vn{c_dabnew.f90} and  \vn{cc_dabnew.f90}. The first package creates and manipulates real Taylor series. In other words, the coefficients of the monomials are \vn{real(dp)}. 
  The complex objects of \secs{sec:complextaylor} and  \sece{sec:complex_8} are made of two real  \vn{taylor}s  or  \vn{real_8}s  respectively. The individual coefficients inside Berz' package \vn{c_dabnew.f90} are real.
  
  It turns out that this is very inconvenient in accelerator physics  when we analyze maps. Since most of our maps are stable, their diagonalized representation contains complex numbers. For example, the map  of \eq{eq:lin1} can be diagonalize 
  into:
%
%]|Expr|[#b @`b___})8# b'4" Chicago^: ;bP8&c0!*-="!Helvetica|:! |
%|""Symbol^:"&c0  L"#*|:#&c0!*,]<c!$1^["" (#:!-<exp<c!$1($:#,Mi|
%| :"&c0  m}}}^:#&c0!*0^0(#:!-<exp<c!$1($:# i :"&c0  m}}}}}"$Monaco^:$&c0!* |
%|where :"&c0  m:#&c0!* ,] 0,N317560429291521:! : ;8/<:#;bP8eq,Z|
%|lam: ;8/=;bP8-;}& b!( b"0 b#8 b$@ b%H b&P!WW}]|[
\begin{align} \Lambda =
\left({\begin{array}{cc}\exp\left({-i\ \mu }\right)&0\\
0&\exp\left({\ i\ \mu }\right)\end{array}}\right)~{\rm w}{\rm h}{\rm e}{\rm r}{\rm e}~\mu \ =
\ 0.317560429291521 \label{eq:lam}\end{align}

In fact, the output  from the code, a \vn{c_damap},   is made of two \vn{c_taylor}. Please notice that the coefficient have a real and imaginary part  corresponding to the cosine and sine of $\mu$ :

\begin{example}
           2  Dimensional map

 Properties, NO =    1, NV =    2, INA =  139
 *********************************************

   1  0.9499999999999998     -0.3122498999199199       1  0


 Properties, NO =    1, NV =    2, INA =  138
 *********************************************

   1  0.9499999999999998      0.3122498999199199       0  1

  No Spin Matrix
  c_quaternion is identity
 No Stochastic Radiation
\end{example}

Finally if FPP were to be used in electron microscopy, the eigenfunctions of $L_z$ representing symmetry around the axis of the microscope are very useful: $x \pm i y$. We can see how a complex TPSA package is almost unavoidable in the field of beam dynamics.\footnote{Of course, Berz's COSY INFINITY handles complex maps.}
 
\subsubsection{The type {\vn{c_damap}} }\label{sec:c_damap}
  
  The type  \vn{c_damap} is defined as
  \begin{example}
 type c_damap
   type (c_taylor) v(lnv)  
   integer :: n=0 
   type(c_spinmatrix) s 
   type(c_quaternion) q
   complex(dp) e_ij(6,6) 
   complex(dp) x0(lnv) 
   logical :: tpsa=.false.
 end type c_damap
  \end{example}


 
There is an obvious resemblance  with \vn{probe_8} which we recall is:
  \begin{example}
    type probe_8
     type(real_8) x(6)     ! Polymorphic orbital ray
     type(spinor_8) s(3)   ! Polymorphic spin s(1:3)
     type(quaternion_8) q 
     type(rf_phasor_8)  ac(nacmax)  ! Modulation of magnet
     integer:: nac=0 !  number of modulated clocks <=nacmax
     real(dp) E_ij(6,6)   !  Envelope for stochastic radiation
           .
           .
  end type probe_8
    \end{example}

The first thing one notices is that \vn{c_damap}  contains \vn{lnv=100} complex Taylor series. Indeed the analysis part of FPP does not put any limit on the dimensionality of phase space beyond \vn{lnv}. For example, if the user tracks six-dimensional phase space (as in BMAD) and adds two modulated clocks, then the component   \vn{v(lnv)} will use 10 Taylor series to represent the map leaving 90 unused. 


The \vn{c_spinmatrix} is a matrix of  \vn{c_taylor} for the three spin directions
  \begin{example}
  type c_spinmatrix
     type(c_taylor) s(3,3)
  end type c_spinmatrix
      \end{example}
and the \vn{c_quaternion} follows the polymorphic quaternion:

  \begin{example}
 type  c_quaternion
  type(c_taylor) x(0:3)
END TYPE c_quaternion
      \end{example}

 It is important to realize that  $\vn{c_damap}$ can be concatenated.  For example, the diagonal matrix $\Lambda$ of \eq{eq:lam} was obtained with a  Fortran  statement which represents a similarity transformation where \vn{normal%atot} turns the original map into a rotation and \vn{c_phasor()} diagonalizes the rotation:
 
   \begin{example1}
 diag=c_phasor(-1)*normal%atot**(-1)*one_period_map*normal%atot*c_phasor()
   \end{example1}

The Fortran symbol \vn{*} is overloaded to represent the ``differential algebraic''  (DA) concatenation of five maps in this example. When we deal with maps around a closed orbit, the maps and the various differential operators we will later discuss,  form a self-consistent differential algebra if the constant part is ignored. These complicated operators we will later define: Lie vector fields, etc \ldots

Most of perturbation theory deals with differential algebraic operators. On the other hand, it is possible to concatenate \vn{c_damap} using truncated power series algebra (TPSA). In the case of TPSA, the constant part of a map is taken into account. In that case, the map concatenation uses the symbol ``\vn{.o.}''. As we alluded at the beginning of  \sec{sec:raymap}, it is sometimes preferable to use a single type for two different purposes: then a new operator must be defined. The component \vn{x0(lnv)} and \vn{tpsa} are related to the TPSA usage of \vn{c_damap} and will be explained later.

A tracking code like PTC produces TPSA maps if we do not compute them  around  the closed orbit because of feed down issues.  Thus most calculations of lattice functions must be preceded by a computation of the closed orbit for the obtention of  self-consistent results. If the maps were of infinite or very large order, then we could always deal with TPSA\footnote{This is view point of COSY INFINITY of Berz but we reject it in ring dynamics although its has its place in other area of beam physics.} maps and the closed orbit search would be part of the map analysis. 

 

  \subsubsection{Interaction between the worlds of probes and   Taylor maps  }\label{sec:mappro}
  
  Let us assume that we want to compute a \vn{probe_8}, called  \vn{polymorphic_probe}, and that we want to track it around some orbit \vn{z0=(z0(1),z0(2))}. For example, \vn{z0} might contain the closed orbit. Since PTC deals with \vn{probe}, we first stick this real initial trajectory into a real \vn{probe}, say \vn{probe0}. The syntax would be:
  
    \begin{code}
     real(dp) :: z0(2) = (/0,0/)  ! special orbit
     type(probe) :: probe0 
     type(probe_8) :: polymorphic_probe  
                  .
                  .
      probe0=z0
      polymorphic_probe = probe0    <----- initial value of polymorphic_probe
      call track(polymorphic_probe)
     \end{code}
  
  However the reader will notice that nothing is said about the initial Taylor value of  \vn{polymorphic_probe}: it will simply acquire the value of \vn{probe0}. The rays will start as real numbers and the final value of  \vn{polymorphic_probe}  after tracking will be two real numbers: no Taylor information. So how do we initialize the \vn{polymorphic_probe} correctly to obtain a map? Here is the code:
  
      \begin{code}
real(dp) :: z0(2) = (/0,0/)  ! special orbit
type(probe) :: probe0 
type(probe_8) :: polymorphic_probe  
type(c_damap) Identity, one_period_map
             .
             .
 probe0=z0
 Identity=1     <-----World of c_damap

 polymorphic_probe = probe0 + Identity   <-----probes and c_damap are mixing
 call track(polymorphic_probe)
 one_period_map=polymorphic_probe       <-----probes and c_damap are mixing
     \end{code}
  
\vn{Identity} is a \vn{c_damap}. The line \vn{Identity=1} turns it into an identity map with {\bf no} constant part. This is the differential algebraic world. 
Then  \vn{probe0} is ``added'' to \vn{Identity} and the appropriate  \vn{probe_8} is  created with the \vn{=} sign. 
  
  Finally, once the tracking is done, it returns the final value of \vn{polymorphic_probe}. Now, if we want to analyze the corresponding map, we perform the reverse assignment 
  \vn{ one_period_map=polymorphic_probe}.  
  
  Someone may wonder why we insist on adding an identity map rather than the Taylor monomials as we did in   \sec{sec:real8code}. Indeed 
   \begin{example}
   Identity=1
    \end{example}
    is equivalent to 
      \begin{example}
       Identity%v(1)=dz_c(1)
       Identity%v(2)=dz_c(2)
    \end{example}   
    and thus   \vn{dz_8(1)} and \vn{dz_8(1)} could have been added directly into the \vn{probe_8} as we did in   \sec{sec:real8code}.
          \begin{example}
       polymorphic_probe%x(1)=z0(1)+dz_8(1)
       polymorphic_probe%x(2)=z0(2)+dz_8(2)
    \end{example}


The answer will become  obvious when we discuss analysis. When we track lattice functions, linear, nonlinear, with or without spin, the initial value involves a canonical transformation. For example, \vn{Identity} would be replaced by 
\vn{normal%atot}. A map like \vn{normal%atot} if it is nonlinear or parameter dependent is a huge beast. But even in a coupled linear system in 2-d-f,  \vn{normal%atot}  involves 16 values. It makes perfect sense to allow its addition to a \vn{probe} to create the appropriate \vn{probe_8} to track.

We are left with spin: how is spin transferred from the \vn{probe_8} to a  \vn{c_damap}.  This  depends on the choice : quaternions versus 3 by 3  rotations. In the case of a rotation, the following code fragments 
 gives us the answer:
 
 \begin{example}
DO I=1,3
 DO J=1,3
   t=R%S(J)%X(I)    ! a probe_8 in converted from real_8 to c_taylor
   DS%S%s(I,J)=t   ! It is  put into the spin matrix of a c_damap
  ENDDO
 ENDDO
\end{example}
 
 The three vectorial spin directions of the \vn{probe_8} \vn{R} are fed into the  \vn{c_damap} \vn{DS}. 
 
 In the case of quaternions, the polymorphic \vn{quaternion_8} is a mirror image of the \vn{c_quaternion}  contained in the \vn{c_damap}. Thus the conversion code is trivial:
 
  \begin{example}
DO I=0,3
  t=r%q%x(i)
  DS%q%x(i)=t
ENDDO
\end{example}

This concludes our overview of the quintessential   types: the various Taylor types, the polymorphs, the probes of PTC and the maps which can be concatenated and analyzed.

\section{Important types and their  operators}\label{sec:typeops}

Tracking codes  such as  PTC, BMAD, TEAPOT, Sixtrack, etc\ldots track particles via brute\footnote{From a certain point of view, symplectic integration is not so brute, but integration nevertheless. The reader is invited to read reference \cite{forestreview} for a complete discussion of the ``Talman'' view point of symplectic integration which the primary tool of PTC.} force integration. The tracking includes phase space and potentially other things such as spin. This is why PTC has a \vn{probe} entity so as to accommodate  anything ``trackable.''   The \vn{probe_8} was invented to accommodate Taylor series. For example, the phase space variables and the spin can be expanded as a Taylor series in some variables. For a  \vn{probe_8}, the extra information carried by the type \vn{probe_8} is passive like the spin. As we explained in \sec{sec:raymap},  \vn{probe_8} can be promoted to a {\it bona fide} Taylor approximation of the map of PTC.

We will now assume that we have a proper map of the type \vn{c_damap}. This map has at least one degree of freedom and represents some dynamical system. We describe the types and the operations associated to \vn{c_damap}.

%z_concat_da_c_damap.f90
\subsection{TPSA? DA? What does that mean?} \label{sec:tpsada}

TPSA stands for ``Truncated Power Series Algebra'' and DA stands for ``Differential Algebra.'' But what does it mean when applied to a typical accelerator ring? Once we cut the mathematical jargon, we will see that 

\begin{itemize}
\item DA operations are used around the closed orbit and thus the constant part of the map is ignored. All the coefficients of the Taylor series stay the same independently of the order invoked. It so happens that the computation of nonlinear differential operators (Lie vector fields for example), are self-consistent because they form a differential algebra. But it is much simpler in our field to state that they are self-consistent because there are no feed down terms.
\item TPSA operations take into account the constant part and the results change as a function of the order. 
\end{itemize}


Let us look at our little code again  %z_concat_da_c_damap.f90
\begin{code}
  subroutine track(z)
  implicit none
  type(real_8) :: z(2) 
  z(1)=z(1)+L*z(2) 
  z(2)=z(2)-B-K_q*z(1)-K_s*z(1)**2 
  end subroutine track
\end{code}

%\pagebreak
with the parameters

\begin{example}
1     ! L
0.001 ! B
.1    ! K_q
1.0   ! K_s
\end{example}

We run the code and invoke DA maps:

\begin{example}
 L
   1.00000000000000
 K_b
  1.000000000000000E-003
 K_q
  0.100000000000000
 K_s
   1.00000000000000
 Lattice Read and polymorphs read
 closed orbit found
  Closed Orbit from Tracking -1.127016653792583E-002  9.951207934035656E-020
 The order of the Taylor series ?
1
 Tpsa =0 DA=1
1

           2  Dimensional map

 Properties, NO =    1, NV =    2, INA =  154
 *********************************************

   0 -0.1127016653792583E-01   0.000000000000000       0  0
   1   1.000000000000000       0.000000000000000       1  0
   1   1.000000000000000       0.000000000000000       0  1


 Properties, NO =    1, NV =    2, INA =  153
 *********************************************

   0 -0.1084202172485504E-18   0.000000000000000       0  0
   1 -0.7745966692414835E-01   0.000000000000000       1  0
   1  0.9225403330758517       0.000000000000000       0  1
\end{example}

The initial closed orbit is computed exactly by a Newton search and we compute the map around it. Notice that the DA map, type \vn{c_damap}, contains  the correct closed orbit. But it is most important to realize that the Taylor coefficients of the map are the correct ones: there is now feed down effect. If we run the same program to second order, we get:

\begin{example}
           2  Dimensional map

 Properties, NO =    2, NV =    2, INA =  155
 *********************************************

   0 -0.1127016653792583E-01   0.000000000000000       0  0
   1   1.000000000000000       0.000000000000000       1  0
   1   1.000000000000000       0.000000000000000       0  1


 Properties, NO =    2, NV =    2, INA =  154
 *********************************************

   0 -0.1084202172485504E-18   0.000000000000000       0  0
   1 -0.7745966692414835E-01   0.000000000000000       1  0
   1  0.9225403330758517       0.000000000000000       0  1
   2  -1.000000000000000       0.000000000000000       2  0
   2  -2.000000000000000       0.000000000000000       1  1
   2  -1.000000000000000       0.000000000000000       0  2
\end{example}

Moreover, we can square the map and call the tracking code for an additional turn:

\begin{example2}
  one_period_map*one_period_map

           2  Dimensional map

 Properties, NO =    2, NV =    2, INA =   64
 *********************************************

   0 -0.1127016653792583E-01   0.000000000000000       0  0
   1  0.9225403330758517       0.000000000000000       1  0
   1   1.922540333075852       0.000000000000000       0  1
   2  -1.000000000000000       0.000000000000000       2  0
   2  -2.000000000000000       0.000000000000000       1  1
   2  -1.000000000000000       0.000000000000000       0  2


 Properties, NO =    2, NV =    2, INA =   63
 *********************************************

   0 -0.1084202172485504E-18   0.000000000000000       0  0
   1 -0.1489193338482967       0.000000000000000       1  0
   1  0.7736209992275551       0.000000000000000       0  1
   2  -1.773620999227555       0.000000000000000       2  0
   2  -5.392322664606813       0.000000000000000       1  1
   2  -4.618701665379258       0.000000000000000       0  2

  No Spin Matrix
  c_quaternion is identity
 No Stochastic Radiation
  Two periods map

           2  Dimensional map

 Properties, NO =    2, NV =    2, INA =   64
 *********************************************

   0 -0.1127016653792583E-01   0.000000000000000       0  0
   1  0.9225403330758517       0.000000000000000       1  0
   1   1.922540333075852       0.000000000000000       0  1
   2  -1.000000000000000       0.000000000000000       2  0
   2  -2.000000000000000       0.000000000000000       1  1
   2  -1.000000000000000       0.000000000000000       0  2


 Properties, NO =    2, NV =    2, INA =   63
 *********************************************

   0 -0.1084202172485504E-18   0.000000000000000       0  0
   1 -0.1489193338482967       0.000000000000000       1  0
   1  0.7736209992275550       0.000000000000000       0  1
   2  -1.773620999227555       0.000000000000000       2  0
   2  -5.392322664606813       0.000000000000000       1  1
   2  -4.618701665379258       0.000000000000000       0  2
\end{example2}

The results are identical to machine precision.  The code fragment is
\begin{code}
 two_period_map=one_period_map*one_period_map
 print *, " one_period_map*one_period_map "
 call PRINT(two_period_map)
 call track(polymorphic_probe)
 two_period_map=polymorphic_probe
 print *, " Two periods map "
 call PRINT(two_period_map)
\end{code}

Notice the syntax for the  concatenation of the maps:
\begin{example}

             two_period_map=one_period_map * one_period_map
 
\end{example}

In the FPP package, the operator \vn{*}  always deals with ``DA'' operations.  The symbol \vn{.o.} makes a TPSA operation. For example, suppose we {\it erroneously} replace  \vn{*} by\vn{.o.} in the same code, the result becomes:

\begin{example2}

 one_period_map .o. one_period_map
 
           2  Dimensional map

 Properties, NO =    2, NV =    2, INA =   64
 *********************************************

   0 -0.2254033307585166E-01   0.000000000000000       0  0
   1  0.9225403330758517       0.000000000000000       1  0
   1   1.922540333075852       0.000000000000000       0  1
   2  -1.000000000000000       0.000000000000000       2  0
   2  -2.000000000000000       0.000000000000000       1  1
   2  -1.000000000000000       0.000000000000000       0  2


 Properties, NO =    2, NV =    2, INA =   63
 *********************************************

   0  0.7459666924148337E-03   0.000000000000000       0  0
   1 -0.1281249674648599       0.000000000000000       1  0
   1  0.8169556986868436       0.000000000000000       0  1
   2  -1.796161332303407       0.000000000000000       2  0
   2  -5.437403330758516       0.000000000000000       1  1
   2  -4.641241998455110       0.000000000000000       0  2

  
  Two periods map

           2  Dimensional map

 Properties, NO =    2, NV =    2, INA =   64
 *********************************************

   0 -0.1127016653792583E-01   0.000000000000000       0  0
   1  0.9225403330758517       0.000000000000000       1  0
   1   1.922540333075852       0.000000000000000       0  1
   2  -1.000000000000000       0.000000000000000       2  0
   2  -2.000000000000000       0.000000000000000       1  1
   2  -1.000000000000000       0.000000000000000       0  2


 Properties, NO =    2, NV =    2, INA =   63
 *********************************************

   0 -0.1084202172485504E-18   0.000000000000000       0  0
   1 -0.1489193338482967       0.000000000000000       1  0
   1  0.7736209992275550       0.000000000000000       0  1
   2  -1.773620999227555       0.000000000000000       2  0
   2  -5.392322664606813       0.000000000000000       1  1
   2  -4.618701665379258       0.000000000000000       0  2

\end{example2}

The x-component of the closed orbit was incorrectly substituted into the map upon concatenation. The results for $p^{final}$ are simply wrong. So the moral of this story:

{\bf When using an integrator, find the closed orbit, then the maps around it and only use ``DA'' operations in the analysis package. The closed orbit search must not be done by the TPSA package but by the original tracking code.}

 Concatenation must use  \vn{*} and powers \vn{**}. For TPSA maps, the equivalent operators are \vn{.o.} and \vn{.oo.}. For example, let us run the same example computing the map around  \vn{z0=(0,0)}.

\begin{example2}
  Closed Orbit from Tracking  -1.127016653792583E-002  9.951207934035656E-020
  Closed Orbit using TPSA map -1.000000000000000E-002  0.000000000000000E+000
  Linear using TPSA map around z=(0,0)

           2  Dimensional map

 Properties, NO =    1, NV =    2, INA =  108
 *********************************************

   1   1.000000000000000       0.000000000000000       1  0
   1   1.000000000000000       0.000000000000000       0  1


 Properties, NO =    1, NV =    2, INA =  107
 *********************************************

   0 -0.1000000000000000E-02   0.000000000000000       0  0
   1 -0.1000000000000000       0.000000000000000       1  0
   1  0.9000000000000000       0.000000000000000       0  1

  No Spin Matrix
  c_quaternion is identity
 No Stochastic Radiation
 
  Linear map around computed by TPSA inversion

           2  Dimensional map

 Properties, NO =    1, NV =    2, INA =  108
 *********************************************

   1   1.000000000000000       0.000000000000000       1  0
   1   1.000000000000000       0.000000000000000       0  1


 Properties, NO =    1, NV =    2, INA =  107
 *********************************************

   1 -0.1000000000000000       0.000000000000000       1  0
   1  0.9000000000000000       0.000000000000000       0  1
\end{example2}

The approximate closed orbit is found by solving 
%
%]|Expr|[#b @`b___})b D# b'4" Chicago^: ;bP8&c0!*-="!Helvetica|:! |
%|""*|:"F,H&c0!)z&c0!*,I,]T,H&c0!)z&c0!*,I,M&c0!)z&c0!*,]0     |
%| :!-<Longrightarrow "#Times|:#     :! $^:#&c0!)z^&c0!*c_,]$^F|
%|_(",M1},H0,I:! : -;}& b!( b"0 b#8 b$@ b%H b&P!WW}]|[
\begin{align} F(\bf z\rm )=
T(\bf z\rm )-\bf z\rm =
0\ \ \ \ \ \ \Longrightarrow \ \ \ \ \  {\bf z}_{c}=
{F}^{-1}(0) \end{align}

This is done by the code (the maketpsa routine is explained near \eq{maketpsa}):

\begin{code}
newton_map=one_period_map; newton_map=maketpsa(newton_map);
newton_map%v(1)=newton_map%v(1)-(1.0_dp.cmono.1)
newton_map%v(2)=newton_map%v(2)-(1.0_dp.cmono.2)


newton_map=newton_map.oo.(-1)    <---- notice .oo. NOT **

print * ," Closed Orbit from Tracking ",z1
z0(1)=newton_map%v(1)
z0(2)=newton_map%v(2)
 print * ," Closed Orbit using TPSA map",z0 
\end{code}

The new map is computed by similarity transformation and only the zeroth order and  linear part is printed:

\begin{example2}
 print * ," Linear using TPSA map around z=(0,0)"
newton_map=one_period_map.cut.2
call print(newton_map)

one_period_map= one_period_map.o.to_closed_orbit  <---- notice .o. NOT *

one_period_map=(to_closed_orbit.oo.(-1)).o.one_period_map  <---- notice .o. and .oo. 

newton_map=one_period_map.cut.2       <---- order higher than 1 are cut


 print * ," Linear map around computed by TPSA inversion " 

call print(newton_map)
\end{example2}

The reader will notice that the linear matrix is very wrong. Of course, this being TPSA, things can be improved by using a higher order. For example, if we increase the order to 10, the result is 


\begin{example2}
  Linear map around computed by TPSA inversion

           2  Dimensional map

 Properties, NO =   10, NV =    2, INA =  117
 *********************************************

   1   1.000000000000000       0.000000000000000       1  0
   1   1.000000000000000       0.000000000000000       0  1


 Properties, NO =   10, NV =    2, INA =  116
 *********************************************

   0 -0.2007594574035456E-08   0.000000000000000       0  0
   1 -0.7745971876000000E-01   0.000000000000000       1  0
   1  0.9225402812400000       0.000000000000000       0  1
\end{example2}

To the extent that we consider the integrator model to be realistic, i.e. exact in the Talman sense (see reference \cite{forestreview} ), there is no doubt that the computation of the closed orbit should be done exactly by the integrator and NOT by the Taylor series package.

\subsection{List of  DA and TPSA operators and associated types} \label{sec:opeda}




\begin{enumerate}
\item  \vn{c_damap*c_damap} and  \vn{c_damap.o.c_damap}
\item  \vn{c_taylor*c_damap} and  \vn{c_taylor.o.c_damap}
\item \vn{c_spinmatrix*c_damap} and  \vn{c_spinmatrix.o.c_damap}
\item \vn{c_quaternion*c_damap} and  \vn{c_quaternion.o.c_damap}
\item \vn{c_spinor*c_damap} and  \vn{c_spinor.o.c_damap}
\item \vn{c_taylor.o.c_ray}
\item \vn{c_damap.o.c_ray} 
\item \vn{c_spinor.o.c_ray} 
\item \vn{c_spinmatrix.o.c_ray} 
\item \vn{c_quaternion.o.c_ray} 
\end{enumerate}

The type \vn{c_ray} is essentially a zeroth order map, i.e., very similar to the type \vn{probe} but associated to FPP and not to the tracking code.It is defined as

\begin{example2}
 TYPE c_ray
  complex(dp) x(lnv)            !# orbital and/or magnet modulation clocks
  complex(dp) s1(3),s2(3),s3(3) !# 3 spin directions
  type(complex_quaternion) q    !# quaternion
  integer n                     !# of dimensions used in x(lnv)
  complex(dp) x0(lnv)           !# the initial orbit around which the map is computed
 end type c_ray
\end{example2}

The type \vn{c_spinor} consists of 3 spin directions:

\begin{example}
  type c_spinor
     type(c_taylor) v(3)
  end type c_spinor
\end{example}

It can be used with the $SO(3)$ or the quaternion algebra to store spin directions.

\subsubsection{Operation .o. and * on c_damap} \label{sec:c_damap}
Let us start with the type \vn{c_damap} which is
  \begin{example}
 type c_damap
   type (c_taylor) v(lnv)  
   integer :: n=0 
   type(c_spinmatrix) s 
   type(c_quaternion) q
   complex(dp) e_ij(6,6) 
   complex(dp) x0(lnv) 
   logical :: tpsa=.false.
 end type c_damap
  \end{example}
  
  When it is created with the assignment

\begin{example}
                             c_damap=probe_8
\end{example}

then the constant part of the map is the final trajectory of the initial ray.  In any ``DA'' concatenation using the operator \vn{*}, this constant part is ignored. Let us do a one-dimensional linear example:
%
%]|Expr|[#b @`b___})># b'4" Chicago^: ;bP8&c0!*-="!Helvetica|:! |
%|""*|:"M,Hx,I,]ax,Kb"#Monaco^:#     and     :"N,Hx,I,]cx,Kd:! |
%|: -;}& b!( b"0 b#8 b$@ b%H b&P!WW}]|[
\begin{align} M(x)=
ax+b~~~~~{\rm a}{\rm n}{\rm d} ~~~~~N(x)=
cx+d \end{align}
Then $M*N$ will be:
%
%]|Expr|[#b @`b___}).# b'4" Chicago^: ;bP8&c0!*-=<c!$1(#"!*|:!M|
%|,JN}},Hx,I,]ac x,Kb""Monaco^:"   : -;}& b!( b"0 b#8 b$@ b%H b&P!WW}]|[
\begin{align}\left({M*N}\right)(x)=
ac\ x+b~~~\end{align}


The TPSA concatenation will be given by
%
%]|Expr|[#b @`b___})2# b'4" Chicago^: ;bP8&c0!*-=<c!$1(%"!*|:!M|
%|,No,NN}},Hx,I,]ac x,Kad,Kb""Monaco^:"  : ;8/<:!;bP8conco: ;8/=|
%|;bP8-;}& b!( b"0 b#8 b$@ b%H b&P!WW}]|[
\begin{align}\left({M.o.N}\right)(x)=
ac\ x+ad+b~~\label{conco}\end{align}

In general, \eq{conco} makes little sense because the variable $x$ is around some orbit while the TPSA map represents the full orbit in the original coordinates. However, if the original coordinates are known, they can be fed into the \vn{c_damap} component \vn{x0} and the map can be transformed as follows:
%
%]|Expr|[#b @`b___})b P# b'4" Chicago^: ;bP8&c0!*-=<c$4Q^"!Times|:!M}|
%|<c!$1^x}""Helvetica|:",F:!,]"#Monaco^:#maketpsa<c!$1^"$*|:$M}|
%|,Hx,I,]a,Hx,MM,Ex0,I,Kb:#  : ;bP;/"<c$4Q^:!;bP8N}<c!$1^x}:",F|
%|:!,]:#maketpsa<c!$1^:$N},Hx,I,]c,Hx,MN,Ex0,I,Kd:#  : ;8/<:$;bP8maketpsa|
%|: ;8/=;bP8-;}& b!( b"0 b#8 b$@ b%H b&P!WW}]|[
\begin{align}\widetilde{M}\left({x}\right)&=
{\rm m}{\rm a}{\rm k}{\rm e}{\rm t}{\rm p}{\rm s}{\rm a}\left({M}\right)(x)=
a(x-M\%x0)+b~~\nonumber \\
\widetilde{N}\left({x}\right)&=
{\rm m}{\rm a}{\rm k}{\rm e}{\rm t}{\rm p}{\rm s}{\rm a}\left({N}\right)(x)=
c(x-N\%x0)+d~~\label{maketpsa}\end{align}

The component flag \vn{tpsa} of \vn{c_damap} is set to true and the map concatenation behaves as in \eq{maketpsa}.  Finally we notice that if the maps $M$ and $N$ were extracted from the same integrator, we expect the variable $N\%x0$ to be the constant $b$ of the map $M$: the final value of the ray when $x=0$ must be the initial value of the ray entering  $N$. This is true whether we integrate through magnets or compute trajectories of bullets: it is a mathematical fact.

The reverse operation is also available. Consider this piece of code:


\begin{code}
type{c_damap} m1,m2,mtot_tpsa,mtot_da,mtot
    .
    .
mtot_da=m2*m1
call print(mtot_da)

m1=maketpsa(m1)
m2=maketpsa(m2)
mtot_tpsa=m2.o.m1
call print(mtot_tpsa)
mtot=makeda(mtot_tpsa)
call print(mtot)
\end{code}
    
We would expect \vn{mtot} and \vn{mtot_da} to be identical. However this is only true if the order of the calculation is 1 or infinite: there is no feed down in a linear calculation and they are exactly computed if the order is infinite. 
Again, we emphasize that the user of an integrator should always manipulate ``DA'' maps. On occasion, we need to evaluate maps or taylor series for a certain value of the ray, this is the only time we should use TPSA operators.

\subsubsection{Operation .o. with type c_ray } \label{sec:c_ray}

We recall the type \vn{c_ray}:

\begin{example2}
 TYPE c_ray
  complex(dp) x(lnv)            !# orbital and/or magnet modulation clocks
  complex(dp) s1(3),s2(3),s3(3) !# 3 spin directions
  type(complex_quaternion) q    !# quaternion
  integer n                     !# of dimensions used in x(lnv)
  complex(dp) x0(lnv)           !# the initial orbit around which the map is computed
 end type c_ray
\end{example2}

The first obvious thing to do is to calculate the effect of a \vn{c_damap} on a \vn{c_ray}. All the so-called matrix codes, from COSY INFINITY to MARYLIE, must have that function since they are not integrators.  The syntax of FPP is simple:
\vn{c_ray}= \vn{c_damap.o.c_ray}.

Here is an example code which does a calculation 4 differents ways in addition to exact tracking from PTC.

\pagebreak


\begin{code}
M1=MAKETPSA(my_map)

x=1.01_dp*closed
ray=x
ray%x0(1:6)=closed
ray=m1.o.ray
write(6,*) " Using a TPSA map "
                                call print(ray)

write(6,*) " Using a DA map "
ray=x
ray%x0(1:6)=closed
ray=my_map.o.ray
                                call print(ray)

write(6,*) " Using a TPSA map and SO(3)"
CALL MAKESO3(m1)
use_quaternion=.FALSE.
ray=x
ray%x0(1:6)=closed
ray=m1.o.ray
                                call print(ray)
write(6,*) " Using a DA map and SO(3) "
CALL MAKESO3(MY_MAP)
use_quaternion=.FALSE.
ray=x
ray%x0(1:6)=closed
ray=my_map.o.ray
                                call print(ray)
                                
use_quaternion=.true.
xs0=x
call propagate(als,xs0,state,fibre1=1)
                               call print(xs0)
\end{code}

\vn{my_map} is a one-turn map produced by PTC.  \vn{m1} is a TPSA map as described by \eq{maketpsa}. This particular run used quaternions. So we also turn both \vn{my_map} and \vn{m1} into maps using $SO(3)$. Finally we compute the exact result as seen by PTC.  In the limit of large order, the Taylor series results converge, as expected, to PTC's results.





\subsubsection{The ** and .oo. operators} \label{sec:powers}


These operators do the expected thing: they raise a \vn{c_damap} to a power where the multiplication is either \vn{*} or \vn{.o.}. If the power is negative, they compute the inverse map. This map will not be unique in the TPSA case \vn{.oo. } because as usual feed down effects will depend on the order of truncation.

\subsection{Types related to analysis} \label{sec:analysis}

The types described here are complex and we refer the reader to reference \cite{thebook2} for detailed examples.

\subsubsection{c_vector_field} \label{sec:analysis}

  \begin{example1}
  TYPE c_vector_field  !@1
   !@1 n dimension used v(1:n) (nd2 by default)
   !@1 nrmax iterations some big integer if eps<1  
   integer :: n=0,nrmax
   !@1 if eps=-integer  then |eps| # of Lie brackets are taken 
   !@ otherwise eps=eps_tpsalie=10^-9
   real(dp) eps
   type (c_taylor) v(lnv)   ! vector field denoted by F below
   type(c_quaternion) q   ! quaternion operator denoted by f below
  END TYPE c_vector_field
   \end{example1} 
  
  The type \vn{c_vector_field} is extremely important in perturbation theory. It is its analysis that permits someone to extract resonances, tunes shifts, damping, etc.... out of the \vn{c_damap}.  In general, if you have a  \vn{c_vector_field}  you can produce a \vn{c_damap} by the process of exponentiation.
  
  %
%]|Expr|[#b @`b___}))# b'4" Chicago^: ;bP8&c0!*-="!Helvetica|:! |
%|""*|:"M:!,F,]-<exp<c!$1(#:"F"#Symbol^:#&c0  /7/1}}:"&c0!*I:! |
%|: -;}& b!( b"0 b#8 b$@ b%H b&P!WW}]|[
\begin{align} M&=\exp\left({F\cdot \nabla }\right)I \end{align}

Here $I$ is the identity.  But one can also act on any map:
%
%]|Expr|[#b @`b___})5# b'4" Chicago^: ;bP8&c0!*-="!Helvetica|:! |
%|""*|:"P:!,F,]-<exp<c!$1(#:"F"#Symbol^:#&c0  /7/1}}:"&c0!*N:! |
%|-<Longleftrightarrow "$Times|:$P,]N:#&c0  .P:$&c0!*M : ;8/<:";bP8eqconc|
%|: ;8/=;bP8-;}& b!( b"0 b#8 b$@ b%H b&P!WW}]|[
\begin{align} P&=\exp\left({F\cdot \nabla }\right)N \Longleftrightarrow P=
N\circ M\ \label{eqconc}\end{align}



The type \vn{c_vector_field}  is general: it will create a map with a constant coefficient if it has itself a constant coefficient. In that case, it is a TPSA object and feed down matters. If it has no constant part, then it is a DA object with total self-consistency. 

We now list the various operations, italic objects are the default value of an  optional variable. The operator $\widehat{F}$ below stands really for %%
%
%]|Expr|[#b @`b___})0# b'4" Chicago^: ;bP8&c0!*-="!Helvetica|:! |
%|<c$5Q^""Times|:"F}q,]"#*|:#F"$Symbol^:$&c0  /7/1:#&c0!*q,Kqf:! |
%|: ;8/<:#;bP8hop, : ;8/=;bP8-;}& b!( b"0 b#8 b$@ b%H b&P!WW}]|[
\begin{align} \widehat{F}q=
F\cdot \nabla q+qf \label{hop?}\end{align}
%
where $\hat{f}$ is a quaternion operator.  The $\widehat{F}$  acts as on a quaternion as:
%
%]|Expr|[#b @`b___})2# b'4" Chicago^: ;bP8&c0!*-="!Helvetica|:! |
%|<c$5Q^""Times|:"H}q,]"#*|:#F"$Symbol^:$&c0  /7/1:#&c0!*q,Kq:!|
%|:#f:! : ;8/<:#;bP8hop: ;8/=;bP8-;}& b!( b"0 b#8 b$@ b%H b&P!WW}]|[
\begin{align} \widehat{F}q=
F\cdot \nabla q+qf \label{hop}\end{align}
%
or $\hat{f}q=qf$.  This reversal order is necessary for the self-consistency of the regular maps and the Lie operators. This is explained in Appendix \ref{sec:compo}



Please take note of the of the reverse ordering in \eq{hop}. It is a consequence of \eq{eqconc} when extended to quaternions.

\begin{enumerate}

\item  \vn{c_vector_field=c_vector_field * c_taylor }        %
%
%]|Expr|[#b @`b___})'# b'4" Helvetica|: ;bP8&c0!*,D"!Symbol^:!&c0  .N|
%|""*|:"&c0!*F:!&c0  /7/1:"&c0!*t: ,D}& b!( b"0 b#8 b$@ b%H b&P!WW}]|[
$\rightarrow F\cdot \nabla t$

\item  \vn{  c_damap =c_vector_field * c_damap }         
%
%]|Expr|[#b @`b___})%# b'4" Helvetica|: ;bP8&c0!*,D"!Symbol^:!&c0  .N|
%|<c$5Q^""Times|:"&c0!*H}"#*|:#M: ,D}& b!( b"0 b#8 b$@ b%H b&P!WW}]|[
$\rightarrow \widehat{F}M$

\item \vn{c_taylor=exp(c_vector_field,c_taylor) }

\item \vn{c_damap=exp(c_vector_field,c_damap:{\it Identity})}
%
%]|Expr|[#b @`b___})&# b'4" Helvetica|: ;bP8&c0!*,D"!Symbol^:!&c0  .N|
%|: &c0!*exp<c!$1^<c$5Q^""*|:"H}}M: ,D}& b!( b"0 b#8 b$@ b%H b&P!WW}]|[
$\rightarrow exp\left({\widehat{F}}\right)M$

\item  \vn{c_vector_field=exp(c_vector_field,c_vector_field)}  See \sec{sec:transbracket} and \eq{afpp}.

\item \vn{c_quaternion=exp(c_vector_field,c_quaternion) } $\rightarrow exp\left({\widehat{F}}\right)q$

\item \vn{c_quaternion=exp(c_quaternion,c_quaternion) } $\rightarrow exp\left({q_2}\right)q_1$ Useful for constant quaternion map: used in the linear normal form with quaternion.

\item \vn{c_spinmatrix=exp(c_spinor,c_spinmatrix) } $\rightarrow exp\left({\omega\times}\right)s$ Useful for constant spinmatrix: used in the linear normal form with $SO(3)$.

\item \vn{ c_vector_field = exp(c_damap,h:{\it 0},epso:computed   ) }   


 %$\rightarrow exp\left({\omega\times}\right)s$ Useful for constant spinmatrix: used in the linear normal form with $SO(3)$.

xxxxxxxxxxxxxxxxxx

\item \vn{exp(c_factored_lie,c_spinmatrix) }

\begin{example}
TYPE c_factored_lie
      integer :: n = 0   
      integer :: dir= 0     
       type (c_vector_field), pointer :: f(:)=>null()                   
END TYPE c_factored_lie
\end{example}


\end{enumerate}
\subsection{Obsolete Types} 
\section{overloading}\label{sec:over}
\section{subpackage}\label{sec:subp}
\section{Lie Map and Lie operator}\label{sec:compo} 

The operator 
%
%]|Expr|[#b @`b___})2# b'4" Chicago^: ;bP8&c0!*-="!Helvetica|:! |
%|<c$5Q^""Times|:"H}q,]"#*|:#F"$Symbol^:$&c0  /7/1:#&c0!*q,Kq:!|
%|:#f:! : ;8/<:#;bP8hop: ;8/=;bP8-;}& b!( b"0 b#8 b$@ b%H b&P!WW}]|[
\begin{align} \widehat{F}q=
F\cdot \nabla q+qf \label{hop1}\end{align}
%
%
is the general operator used by FPP.   If we let this operator act on the identity map $I_{total}$, which contains the orbital identity and the unit quaternion,  we obtain a map denoted by ($m,q)$:
%
%]|Expr|[#b @`b___})b D# b'4" Chicago^: ;bP8&c0!*-="!Helvetica|:! |
%|""Monaco^:"if    $^"#Times|:#I(!total}_:!,F,]<c!$1(#$^:#I(!orbital}|
%|_,L1}}: ;bP;/":";bP8     then  :!-<exp<c!$1^<c$5Q^:#H}}$^I(!total}|
%|_:!,F,]<c!$1))# b'4-<exp<c!$1)## b'4"$*|:$F"%Symbol^:%&c0  /7|
%|/1}& b!( b"0 b#8 b$@ b%H b&P!WW}}$^:#&c0!*I(!orbital}_,L:!-<exp|
%|<c!$1^<c$5Q^:#H}}1}& b!( b"0 b#8 b$@ b%H b&P!WW}} ,]:! <c!$1)## b'4|
%|:$m:#,L:$q}& b!( b"0 b#8 b$@ b%H b&P!WW}} : ;8/<:$;bP8eq,Zko: ;8/=|
%|;bP8-;}& b!( b"0 b#8 b$@ b%H b&P!WW}]|[
\begin{align} {\rm i}{\rm f}~~~~{I}_{total}&=\left({{I}_{orbital},1}\right)\nonumber \\
~~~~~{\rm t}{\rm h}{\rm e}{\rm n}~~\exp\left({\widehat{F}}\right){I}_{total}&=\left({\exp\left({F\cdot \nabla }\right){I}_{orbital},\exp\left({\widehat{F}}\right)1}\right)\ =
 \left({m,q}\right)\ \label{eq:ko}\end{align}
The map $ \left({m,q}\right)$ is a regular spin-orbital map.  Let us assume that we concatenate this map with another spin-orbital map $ \left({n,l}\right)$. Then the total map is just:
%
%]|Expr|[#b @`b___})/# b'4" Chicago^: ;bP8&c0!*-="!Helvetica|:! |
%|""Times|:"U:!,]<c!$1)## b'4"#*|:#n:",L:#l|
%|}& b!( b"0 b#8 b$@ b%H b&P!WW}}<c!$1)## b'4m:",L:#q|
%|}& b!( b"0 b#8 b$@ b%H b&P!WW}},]<c!$1))# b'4n"$Symbol^:$&c0  .P|
%|:#&c0!*m:",L:#l:$&c0  .P:#&c0!*m q}& b!( b"0 b#8 b$@ b%H b&P!WW}}|
%| : ;8/<:#;bP8eq,Zcon: ;8/=;bP8-;}& b!( b"0 b#8 b$@ b%H b&P!WW}]|[
\begin{align} U=\left({n,l}\right)\left({m,q}\right)=
\left({n\circ m,l\circ m\ q}\right)\ \label{eq:con}\end{align}
%
However, thanks to our right to left quaternion operator in \eq{hop1}, the full Lie map preserves the substitution rules which are known to be correct for a pure orbital Lie operator:
%
%]|Expr|[#b @`b___})b C# b'4" Chicago^: ;bP8&c0!*-="!Helvetica|:! |
%|""Times|:"U:!,]-<exp<c!$1^<c$5Q^:"H}}<c!$1)## b'4"#*|:#n:",L:#l|
%|}& b!( b"0 b#8 b$@ b%H b&P!WW}}:!,F,]<c!$1))# b'4:#n"$Symbol^:$&c0  .P|
%|:#&c0!*m:",L:#l:$&c0  .P:#&c0!*m q}& b!( b"0 b#8 b$@ b%H b&P!WW}}|
%| : ;bP;/""%Monaco^:%;bP8 or:!,F: ;bP;/":!;bP8 :%  :#l:$&c0  .P|
%|:#&c0!*m q:!,F,]-<exp<c!$1^<c$5Q^:"H}}:#l  : ;8/<:#;bP8eq,Zconq|
%|: ;8/=;bP8-;}& b!( b"0 b#8 b$@ b%H b&P!WW}]|[
\begin{align} U=\exp\left({\widehat{F}}\right)\left({n,l}\right)&=\left({n\circ m,l\circ m\ q}\right)\ \nonumber \\
~{\rm o}{\rm r}&\nonumber \\
 ~~l\circ m\ q&=\exp\left({\widehat{F}}\right)l\ \ \label{eq:conq}\end{align}

\section{Transformation of a  Lie operator}\label{sec:trans} 

Consider the Lie map $\cal A$ operator associated with the phase space map $A=(a,\alpha)$. It acts on a phase space map $M=(m,q)$ (see \sec{sec:compo}) following the formula:
%
%]|Expr|[#b @`b___}),# b'4" Chicago^: ;bP8&c0!*-="!Helvetica|:! |
%|: A<c!$1(#""*|:"m,Lq}}:!,F,]<c!$1((m"#Symbol^:#&c0  .Pa:"&c0!*,L|
%|q:#&c0  .P:"&c0!*a:#&c0  a}}: ;8&c0!*/<:";bP8eq,Zkoopman: ;8/=|
%|;bP8-;}& b!( b"0 b#8 b$@ b%H b&P!WW}]|[
\begin{align} {\cal A}\left({m,q}\right)&=\left({m\circ \alpha ,q\circ a\alpha }\right)\label{eq:koopman}\end{align}
How does a vector field $\widehat{F}$ as in \eq{hop1} if transformed by the map of \eq{eq:koopman}? This has to be done by a similarity transformation:
%
%]|Expr|[#b @`b___})6# b'4" Chicago^: ;bP8&c0!*-="!Helvetica|:! |
%|""*|:" : A<c!$1()"#Times|:#F"$Symbol^:$&c0  /7/1:"&c0!*,K:!-<|
%|hat-[:"f:!-]}}$^: A_(":!,M1},F,]:" <c$4Q^F}:$&c0  /7/1:"&c0!*,K|
%|:!-<hat-[<c$4Q^:"f}:!-] : ;8/<:";bP8aacts: ;8/=;bP8-;|
%|}& b!( b"0 b#8 b$@ b%H b&P!WW}]|[
\begin{align} \ {\cal A}\left({F\cdot \nabla +\hat{f}}\right){{\cal A}}^{-1}&=\ \widetilde{F}\cdot \nabla +\hat{\widetilde{f}} \label{aacts}\end{align}
%
The answer for $\widetilde{F}$ and  $\widetilde{f}$ is:
%
%]|Expr|[#b @`b___})8# b'4" Chicago^: ;bP8&c0!*-="!Helvetica|:! |
%|$^<c$4Q^""*|:"F}^k_:!,F,]<c!$1(#$^:"F^i_$^"#Symbol^:#&c0  .V^|
%|:"&c0!*i_$^a^k(",M1}}}:#&c0  .P:"&c0!*a: ;bP;/":!;bP8 -<hat-[|
%|"$Times|:$f:!-],F,]<c!(A(&<c!$1(#$^<c$4Q^:"F}^k_$^:#&c0  .V^:"&c0!*k|
%|_$^:#&c0  a_(":"&c0!*,M1}}},K$^:#&c0  a_(":"&c0!*,M1}f:#&c0  .P|
%|:"&c0!*a}}:#&c0  .P:"&c0!*a:! : ;8/<:";bP8eq,Ztransfgrag: ;8/=|
%|;bP8-;}& b!( b"0 b#8 b$@ b%H b&P!WW}]|[
\begin{align} {\widetilde{F}}_{k}&=\left({{F}_{i}{\partial }_{i}{a}_{k}^{-1}}\right)\circ a\nonumber \\
 \hat{f}&=\left\{{\left({{\widetilde{F}}_{k}{\partial }_{k}{\alpha }^{-1}}\right)+{\alpha }^{-1}f\circ a}\right\}\circ a \label{eq:transfgrag}\end{align}

\section{Lie bracket and Lie bracket operator}\label{sec:transbracket}

We first evaluate the commutator of two line operators $\widehat{F}$ and  $\widehat{H}$:
%
%]|Expr|[#b @`b___})6# b'4" Chicago^: ;bP8&c0!*-="!Helvetica|:! |
%|<c!=Q(#<c$5Q^""Times|:"F},L<c$5Q^H}}}:!,F,]<c!=Q(5"#*|:#F"$Symbol^:$&c0  /7|
%|/1:#&c0!*,K:!-<hat-[:#f:!-] ,L:#H:$&c0  /7/1:#&c0!*,K:!-<hat-[|
%|h-] }}: ;bP;/":!;bP8 ,F,], :#G:$&c0  /7/1:#&c0!*,K:!-<hat-[:#g|
%|:!-] : ;8/<:#;bP8hopc: ;8/=;bP8-;}& b!( b"0 b#8 b$@ b%H b&P!WW}]|[
\begin{align} \left[{\widehat{F},\widehat{H}}\right]&=\left[{F\cdot \nabla +\hat{f} ,H\cdot \nabla +\hat{h} }\right]\nonumber \\
 &=G\cdot \nabla +\hat{g} \label{hopc}\end{align}
 
The answer for $\widehat{G}$ is: 
%
%]|Expr|[#b @`b___})b D# b'4" Chicago^: ;bP8&c0!*-="!Helvetica|:! |
%|""*|:"G:!,F,] <c!,Q(#"#Times|:#F,LH}},]F"$Symbol^:$&c0  /7/1:"&c0!*H|
%|,MH:$&c0  /7/1:"&c0!*F: ;bP;/":!;bP8 g,F,]<c!=Q(#:#h,Lf}},KF:$&c0  /7|
%|/1:"&c0!*h,MG:$&c0  /7/1:"&c0!*f:! : ;8/<:!;bP8liebra: ;8/=;bP8-;|
%|}& b!( b"0 b#8 b$@ b%H b&P!WW}]|[
\begin{align} G&= \left\langle{F,H}\right\rangle=
F\cdot \nabla H-H\cdot \nabla F\nonumber \\
 g&=\left[{h,f}\right]+F\cdot \nabla h-G\cdot \nabla f \label{liebra}\end{align}


We can define a generalised Lie bracket between the vectors and the quaternions defining the Lie operators: 
%
%]|Expr|[#b @`b___})&# b'4" Chicago^: ;bP8&c0!*-=<c%"C^<cY A(#|
%|<c!$1(#"!*|:!G,Lg}}""Helvetica|:",]<c!,Q(#<c!$1(#F,Lf}},L<c!$1|
%|(#H,Lh}}}}}}()"#Monaco^:#FPP,Gs c"$Times|:$-?:#vector:$-?:#field}|
%|_}: ;8/<:!;bP8liebrafpp: ;8/=;bP8-;}& b!( b"0 b#8 b$@ b%H b&P!WW}]|[
\begin{align}\underbrace{\left({G,g}\right)=\left\langle{\left({F,f}\right),\left({H,h}\right)}\right\rangle}\limits_{{\rm F}{\rm P}{\rm P}'{\rm s}~{\rm c}\_{\rm v}{\rm e}{\rm c}{\rm t}{\rm o}{\rm r}\_{\rm f}{\rm i}{\rm e}{\rm l}{\rm d} }^{}\label{liebrafpp}\end{align}




In the code, FPP, it is truly \eq{liebrafpp} which is implemented: vector fields and Lie maps are not represented by a big linear matrix acting on monomials but by  differential operators.

Finally we can defined the Lie which acts on the vector field. Going back to \eq{aacts}, let us assume that $\cal A$ is represented by a Lie exponent $\widehat{A}$,
%
%]|Expr|[#b @`b___}))# b'4" Chicago^: ;bP8&c0!*-="!Helvetica|:! |
%|: A:!,F,]-<exp<c!$1^<c$5Q^""*|:"A}}: :! : -;|
%|}& b!( b"0 b#8 b$@ b%H b&P!WW}]|[
\begin{align} {\cal A}&=\exp\left({\widehat{A}}\right) \end{align}
%
 then we must have:
%
%]|Expr|[#b @`b___})6# b'4" Chicago^: ;bP8&c0!*-="!Helvetica|:! |
%|""*|:" : A<c!$1()"#Times|:#F"$Symbol^:$&c0  /7/1:"&c0!*,K:!-<|
%|hat-[:"f:!-]}}$^: A_(":!,M1},F,]:" <c$4Q^F}:$&c0  /7/1:"&c0!*,K|
%|:!-<hat-[<c$4Q^:"f}:!-] : ;8/<:";bP8aacts: ;8/=;bP8-;|
%|}& b!( b"0 b#8 b$@ b%H b&P!WW}]|[
\begin{align} \ {\cal A}\left({F\cdot \nabla +\hat{f}}\right){{\cal A}}^{-1}&=\ \widetilde{F}\cdot \nabla +\hat{\widetilde{f}} \label{aacts}\end{align}

 

%
%]|Expr|[#b @`b___});# b'4" Chicago^: ;bP8&c0!*-="!Helvetica|:! |
%|""*|:" : A<c$5Q^:"F}$^: A_(":!,M1},F,]:" :!-<exp<c!$1^<c$5Q^:"A}}|
%|<c$5Q^F}:!-<exp<c!$1(":",M<c$5Q^A}}}:! : ;bP;/":!;bP8 ,F,]-<exp|
%|<c!$1(#: ,Z<c$5Q^:"A}: ,Z}}<c$5Q^:"F} : ;8/<:";bP8asimillie: ;8/=|
%|;bP8-;}& b!( b"0 b#8 b$@ b%H b&P!WW}]|[
\begin{align} \ {\cal A}\widehat{F}{{\cal A}}^{-1}&=\ \exp\left({\widehat{A}}\right)\widehat{F}\exp\left({-\widehat{A}}\right) \nonumber \\
 &=\exp\left({\dragt\widehat{A}\dragt}\right)\widehat{F}\ \label{asimillie}\end{align}
where
%
%]|Expr|[#b @`b___})0# b'4" Chicago^: ;bP8&c0!*-="!Helvetica|:! |
%|: ,Z<c$5Q^""*|:"A}: ,Z<c$5Q^"#Times|:#F}: ,]<c!=Q)## b'4<c$5Q|
%|^:"A}: ,L<c$5Q^:#F}}& b!( b"0 b#8 b$@ b%H b&P!WW}}:",]<c$5Q^A}|
%|<c$5Q^:#F}: ,M<c$5Q^:#F}<c$5Q^A}:! : -;|
%|}& b!( b"0 b#8 b$@ b%H b&P!WW}]|[
\begin{align} \dragt\widehat{A}\dragt\widehat{F}=\left[{\widehat{A},\widehat{F}}\right]=
\widehat{A}\widehat{F}-\widehat{F}\widehat{A} \end{align}
and finally, thanks to the homomorphism between the commutators and the Lie bracket:
%
%]|Expr|[#b @`b___})4# b'4" Chicago^: ;bP8&c0!*-="!Helvetica|:! |
%|""*|:" :! <c$5Q^<c$4Q^"#Times|:#F}}:!,]-<exp<c!$1(#: ,Z<c$5Q^|
%|:"A}: ,Z}}<c$5Q^:"F}:!,F,]  $(""$Monaco^:$Operator<c!(A((:!-<|
%|exp<c!$1(':",Z,HA,La,I,Z}},HF,Lf,I}}}__:!   : ;8/<:";bP8asimillieh|
%|: ;8/=;bP8-;}& b!( b"0 b#8 b$@ b%H b&P!WW}]|[
\begin{align} \  \widehat{\widetilde{F}}=\exp\left({\dragt\widehat{A}\dragt}\right)\widehat{F}&=  {{\rm O}{\rm p}{\rm e}{\rm r}{\rm a}{\rm t}{\rm o}{\rm r}\left\{{\exp\left({:(A,a):}\right)(F,f)}\right\}}^{}   \label{asimillieh}\end{align}

%
The word ``Operator'' in front of the curly bracket in \eq{asimillieh} indicates that the object inside the brackets has a ``hat'' on top of it and is thus a Lie operator.  The colon around $:(A,a):$ indicates, \`a la Dragt, that a Lie bracket must be taken with what follows as defined by \eqs{liebra} and \eqe{liebrafpp}. This Lie bracket is in FPP and is defined by the Fortran operator ``\vn{.lb.}''. So we have:
%
%
%]|Expr|[#b @`b___})/# b'4" Chicago^: ;bP8&c0!*-="!Helvetica|:! |
%|""*|:" :! <c!$1(#<c$4Q^"#Times|:#F},L<c$4Q^f}}}:!,F,]  $(""$Monaco^:$Operator|
%|<c!(A((:!-<exp<c!$1(':",Z,HA,La,I,Z}},HF,Lf,I}}}__:!  : ;8/<:";bP8afpp|
%|: ;8/=;bP8-;}& b!( b"0 b#8 b$@ b%H b&P!WW}]|[
\begin{align} \  \left({\widetilde{F},\widetilde{f}}\right)&=  {{\rm O}{\rm p}{\rm e}{\rm r}{\rm a}{\rm t}{\rm o}{\rm r}\left\{{\exp\left({:(A,a):}\right)(F,f)}\right\}}^{}  \label{afpp}\end{align}

\Eq{afpp} is the complete equivalent of \eq{eq:transfgrag}.  In \eq{afpp} the Lie operator (vector field) of $\cal A$ is known while in \eq{eq:transfgrag} we know only the Taylor spin-orbital maps $(A,a)$.

\section{Logarithm of a map and  ``DA'' self-consistency}\label{sec:logval}

We first display the recursive loop for the calculation of the Lie operator of a spin-orbital map with quaternions. Then we explain the type of validation of all our operators in the differential algebraic (no feed down) that can be performed by FPP to check weed out theory or programming mistakes.
 
 \subsection{ The logarithm of a Lie spin-orbital map}\label{sec:log}  
If a matrix $M$ is near the identity, the following series converges:
%
%]|Expr|[#b @`b___})+# b'4" Chicago^: ;bP8&c0!*-="!Helvetica|:! |
%|-<log<c!$1^""*|:"M}:!,F,]<c%#D("$^<c!$1(":",M1}}_(#n,K1}<2^$^|
%|<c!$1(#M,M1}}_^n^n}}(":!-<sum}(#:"n,]1}^"#Symbol^:#&c0  .E}: ;8&c0!*/<|
%|:";bP8logm: ;8/=;bP8-;}& b!( b"0 b#8 b$@ b%H b&P!WW}]|[
\begin{align} \log\left({M}\right)&=\sum\limits_{n=
1}^{\infty } {\left({-1}\right)}^{n+1}{{\left({M-1}\right)}^{n} \over n}\label{logm}\end{align}
%
Of course this applies trivially to a linear map of phase space. What about a Lie map? Consider a nonlinear map $(M,q)$ and let us assume that it can be approximated by a Lie exponent:
%
%]|Expr|[#b @`b___})5# b'4" Chicago^: ;bP8&c0!*-=<c!$1(#"!*|:!m|
%|,Lq}}""Helvetica|:",F,]-<exp<c!$1():!F"#Symbol^:#&c0  /7/1, :!&c0!*,K|
%|:"-<hat-[:!f:"-]}}<c!$1(#:!I,L1}}: ;bP;/":";bP8 ,F:! :#&c0  .[|
%|<c!$1(4:!&c0!*I ,K F:#&c0  /7/1:!&c0!*I,K'b M,L1,K:"-<hat-[:!f|
%|:"-]1:!,K}}: ;bP;/":";bP8 ,F:#&c0  .[<c!$1(+:!&c0!*I ,K F,K'b M|
%|,L1,Kf}}: ;8/<:!;bP8expIa: ;8/=;bP8-;}& b!( b"0 b#8 b$@ b%H b&P!WW}]|[
\begin{align}\left({m,q}\right)&=\exp\left({F\cdot \nabla +\hat{f}}\right)\left({I,1}\right)\nonumber \\
 &\ \approx \left({I\ +\ F\cdot \nabla I+\cdots,1+\hat{f}1+}\right)\nonumber \\
 &\approx \left({I\ +\ F+\cdots,1+f}\right)\label{expIa}\end{align}
%
The Lie map $\exp\left({F\cdot \nabla + \hat{f}}\right)$ acts on the space of functions and thus it is possible to write a matrix for it using a basis made of monomials. For example, in 1-d-f, for polynomials of degree $n_0$, the space of  polynomials is of dimension $(n_0+2)!\over {n_0!2!}$. Therefore the matrix for the orbital of  $\exp\left({F\cdot \nabla }\right)$ is of dimension $({(n_0+2)!\over {n_0!2!}})^2$. This matrix, as I pointed out in reference \cite{thebook}, is the transpose of the matrix which propagates the moments.  

Here I do not have matrices in the nonlinear case, so I must be a little more resourceful. First one notices that    \eq{expIa} gives us a trivial approximation of the vector field:
%
%]|Expr|[#b @`b___})5# b'4" Chicago^: ;bP8&c0!*-="!Helvetica|:! |
%|,H""*|:"F,Lf,I:!,F"#Symbol^:#&c0  .[:"&c0!*,Hm,Lq,I,M<c!$1(#I|
%|,L1}}:! : ;8/<:";bP8expIa1: ;8/=;bP8-;|
%|}& b!( b"0 b#8 b$@ b%H b&P!WW}]|[
\begin{align} (F,f)&\approx (m,q)-\left({I,1}\right) \label{expIa1}\end{align}
%
I proceed further by assuming that the vector field $(F,f)$ is already known to some order and that the result is $(F^k,f^k)$. I can write:
%
%]|Expr|[#b @`b___})2# b'4" Chicago^: ;bP8&c0!*-="!Helvetica|:! |
%|-<exp<c!$1(&""*|:",M$^F_^k"#Symbol^:#&c0  /7/1:"&c0!*,M$^f_^k}}|
%|<c!$1(#m,Lq}}:!,F,]<c!$1(#I,L1}} ,K <c!$1(#"$Times|:$t,Lu}} : ;8/<|
%|:";bP8kint: ;8/=:!;bP8 : -;}& b!( b"0 b#8 b$@ b%H b&P!WW}]|[
\begin{align} \exp\left({-{F}^{k}\cdot \nabla -{f}^{k}}\right)\left({m,q}\right)&=\left({I,1}\right) + \left({t,u}\right)\ \label{kint} \end{align}
%
%
This algorithm starts with $(t,u)=(m-I,q-1)$. At the end we expect $t$ and $u$ to be zero. My goal is to find a relatively fast algorithm. The first step is to find a vector field which can reproduce the map $(I+t,1+u)$. To second-order in $(t,u)$, I can write:
%
%]|Expr|[#b @`b___})b M# b'4" Chicago^: ;bP8&c0!*-="!Helvetica|:! |
%|-<exp<c!$1(&$^""Symbol^:"&c0  t^"#*|:#&c0!*3_:"&c0  /7/1:#&c0!*,K|
%| $(%:!-<hat-[:"&c0  q:!&c0!*-]}^:#3_}}:! ,H:#I,L1,I:!,F,] ,H"$Times|:$I|
%|,L1,I,K,Ht,Lu,I: ;8/<:#;bP8eqfort: ;8/=:";bP8 :!-<-< "%Monaco^:%where|
%|  <c!$!(%:!-<vphantom-[:"&c0  D:!&c0!*-]}}$^:"&c0  t^:#&c0!*3|
%|_,L$(%:!-<hat-[:"&c0  q:!&c0!*-]}^:#3_<c! 1(%:!-<vphantom-[:"&c0  D|
%|:!&c0!*-]}} ,],F:#,Ht,Lu,I,K$^:"&c0  e^:#&c0!*2_: .O-;|
%|}& b!( b"0 b#8 b$@ b%H b&P!WW}]|[
\begin{align} \exp\left({{\tau }_{3}\cdot \nabla +\ {\hat{\theta }}_{3}}\right) (I,1)&= (I,1)+(t,u)\label{eqfort} \\ {\rm w}{\rm h}{\rm e}{\rm r}{\rm e}~~\left({\vphantom{\Delta }}\right.{\tau }_{3},{\hat{\theta }}_{3}\left.{\vphantom{\Delta }}\right) =&(t,u)+{\varepsilon }_{2}\nonumber 
\end{align}
%
Solving for ${\varepsilon }_{2}$, I get:
%
%]|Expr|[#b @`b___})3# b'4" Chicago^: ;bP8&c0!*-="!Helvetica|:! |
%|$^""Symbol^:"&c0  e^"#*|:#&c0!*2_:!,F,]:#,M<2^1^2}<c!(A()t:"&c0  /7|
%|/1, :#&c0!*,K:!-<hat-[:#u:!-]}}<c!$1(#:#t,Lu}},]<c!$1(-t:"&c0  /7|
%|/1:#&c0!*t,Lt:"&c0  /7/1:#&c0!*u,K$^u_^2}} :! : ;8/<"$Times|:$eq|
%|:!,Ze2: /=;bP8-;}& b!( b"0 b#8 b$@ b%H b&P!WW}]|[
\begin{align} {\varepsilon }_{2}&=-{1 \over 2}\left\{{t\cdot \nabla +\hat{u}}\right\}\left({t,u}\right)=
\left({t\cdot \nabla t,t\cdot \nabla u+{u}^{2}}\right)\  \label{eq:e2}\end{align}
%
I can then rewrite \eq{eqfort} using \eq{eq:e2}:
%
%]|Expr|[#b @`b___})=# b'4" Chicago^: ;bP8&c0!*-="!Helvetica|:! |
%|-<exp<c!$1(&""*|:",M$^F_^k"#Symbol^:#&c0  /7/1:"&c0!*,M$(%:!-<|
%|hat-[:"f:!-]}_^:"k}}: M:!,F:#&c0  .[:!&c0!*-<exp<c!$1(%$^:#&c0  t|
%|^:"&c0!*3_:#&c0  /7/1:"&c0!*,K$(%:!-<hat-[:#&c0  q:!&c0!*-]}^|
%|:"3_}}: ;bP;/":!;bP8 ,F:#&c0  /?: ;bP;&c0!*/":!;bP8 : M:!,F,]-<|
%|exp<c!$1(%$^:"F_^k:#&c0  /7/1:"&c0!*,K$(%:!-<hat-[:"f:!-]}_^:"k}}|
%|:!-<exp<c!$1('$^:#&c0  t^:"&c0!*3_:#&c0  /7/1:"&c0!* ,K$(%:!-<|
%|hat-[:#&c0  q:!&c0!*-]}^:"3_}}: ;8/<:";bP8kintr: ;8/=:!;bP8 : -;|
%|}& b!( b"0 b#8 b$@ b%H b&P!WW}]|[
\begin{align} \exp\left({-{F}^{k}\cdot \nabla -{\hat{f}}^{k}}\right){\cal M}&\approx \exp\left({{\tau }_{3}\cdot \nabla +{\hat{\theta }}_{3}}\right)\nonumber \\
 &\Downarrow \nonumber \\
 {\cal M}&=\exp\left({{F}^{k}\cdot \nabla +{\hat{f}}^{k}}\right)\exp\left({{\tau }_{3}\cdot \nabla \ +{\hat{\theta }}_{3}}\right)\label{kintr} \end{align}
%
%
Now I can apply the Baker-Campbell-Hausdorff formula (CBH) to go to the next step in the iteration:
%
%]|Expr|[#b @`b___})4# b'4" Chicago^: ;bP8&c0!*-="!Helvetica|:! |
%|<c!$1(#$^""*|:"F_(#k,K1},L$^f_(#k,K1}}}:!,F,]<c!$1(#$^:"F_^k,L|
%|$^f_^k}},K<c!$1(#$^"#Symbol^:#&c0  t^:"&c0!*3_,L$^:#&c0  q^:"&c0!*3|
%|_}},K<2^1^2}<c!,Q)## b'4<c!$1(#$^F_^k,L$^f_^k}},L<c!$1(#$^:#&c0  t|
%|^:"&c0!*3_,L$^:#&c0  q^:"&c0!*3_}}}& b!( b"0 b#8 b$@ b%H b&P!WW}}|
%|,K"$Monaco^:$higher order:"'b M:! : ;8/<:";bP8cbhft: ;8/=;bP8-;|
%|}& b!( b"0 b#8 b$@ b%H b&P!WW}]|[
\begin{align} \left({{F}^{k+1},{f}^{k+1}}\right)&=\left({{F}^{k},{f}^{k}}\right)+\left({{\tau }_{3},{\theta }_{3}}\right)+{1 \over 2}\left\langle{\left({{F}^{k},{f}^{k}}\right),\left({{\tau }_{3},{\theta }_{3}}\right)}\right\rangle+{\rm h}{\rm i}{\rm g}{\rm h}{\rm e}{\rm r}~{\rm o}{\rm r}{\rm d} {\rm e}{\rm r}\cdots \label{cbhft}\end{align}
The Lie bracket in \eq{cbhft} was defined in  \eqs{liebra} and \eqe{liebrafpp}.

 \subsection{ Validation of all these ``DA'' operators }\label{sec:log}

Below is a code fragment which allows us to illustrate the results of \secs{sec:compo}, \sece{sec:trans} and \sece{sec:transbracket}:


A=exp(vf)      ~~~~~~~~~\mbox{{\color{green} implements   \eq{eq:ko}}}\hfill\linebreak
f=c_logf_spin(my_map)    ~~~~~~~~~~~~~~~ \mbox{{\color{green} implements the result of \sec{sec:log}}}\hfill\linebreak
 
id=A**(-1)*my_map*A  \hfill\linebreak
f_tilde=c_logf_spin(id) ~~~ \mbox{{\color{green} Uses the logarithm to get the results of \eq{aacts}}} \hfill\linebreak

vf_s=A*f ~~~~~~~~~  \mbox{{\color{green} Implements \eq{eq:transfgrag}}}    \hfill\linebreak   
vf_a=exp(vf,f) ~~~~~~~~  \mbox{{\color{green} Implements \eq{afpp}}} \hfill\linebreak

vf_s=vf_s-f_tilde  ~~~~~~~~   \mbox{{\color{green} Compares the logarithm of \eq{aacts} with \eq{eq:transfgrag}}}    \hfill\linebreak
\mbox{call c_full_norm_vector_field(vf_s,norm)}\hfill\linebreak
\mbox{print *, "norm",norm} \hfill\linebreak
\mbox{vf_a=vf_a-f_tilde}  ~~~~~~~~   \mbox{{\color{green} Compares the logarithm of \eq{aacts} with \eq{afpp}}} \hfill\linebreak
\mbox{call c_full_norm_vector_field(vf_a,norm)} \hfill\linebreak
\mbox{print *, "norm",norm} \hfill\linebreak


The norms produced in the above fragment are zero to machine precision provided that map and vector fields involved have {\bf no} constants parts. All differential operators produce self-consistent results. For the mathematicians, this result comes from the fact that all the Lie operator form a differential algebra. For physicists, they are self-consistent because they are all around an orbit with no feed down effects.

\bibliography{nlinear}


\end{document}

 Let us assume that a person wants the linear lattice functions. The first step would be to compute the closed orbit and then find the matrix around the said orbit. A ``TPSA'' package can find the matrix around any orbit including the closed orbit found by the integrator. In a machine with errors or fringe fields or bizarre models, this closed orbit is not the so-called design orbit.  A code capable of computing Taylor expansions around any orbit will  thus find the matrix around the closed orbit.This can be done with truncated power series, i.e., TPSA.

Once the closed orbit is found, we can compute Taylor maps around that orbit. All the Taylor maps we compute are around that orbit and thus the orbit itself is not used in an approximate calculation using the Taylors maps. Some of these calculations involve differential operators like vector fields. We could, although we do not usually, only play with vector fields. The question would be: if we truncated all the vector fields to order  $N_0$, the order of the Taylor series package and manipulated these vector fields, do we get the same answer if we manipulated the Taylor maps associated with the vector fields? The answer is yes if we are doing everything around the closed orbit and the maps have no constant term.
However a mathematician can say that our Lie operators,i.e. the vector fields, form a differential algebra and this insures the self-constancy of the results. 
